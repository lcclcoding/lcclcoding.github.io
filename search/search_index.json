{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PY2 OOP","text":"<p>Welcome to the world of Objects!</p> <p>Congratulations on making it this far. With you knowledge gained from all the 186 exercises, you're ready to explore a new programming paradigm: Object-Oriented Programming!</p> <p>Unlike the procedural approach to programming, whereby we create procedure (functions) to do repetitive task, in OOP you will be learning how to model objects (possibly real world object) using code!</p> <p>This website will host the materials: notes, exercise and project for the PY2 OOP curriculum</p>"},{"location":"exercises/01/ex01/","title":"Exercise 1: Circles","text":"<p>In this exercise, you\u2019ll create your first class in Python!</p>"},{"location":"exercises/01/ex01/#brief","title":"Brief","text":"<p>Suppose you have three circles with radii of 5, 10, and 20, respectively. Model these circles as objects so that you can easily determine each circle\u2019s radius, diameter, area, and perimeter.</p> <p></p>"},{"location":"exercises/01/ex01/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub. </p>"},{"location":"exercises/01/ex01/#task-1-create-a-class-diagram","title":"Task 1: Create a Class Diagram","text":"<p>Before you start coding, open the <code>classes.drawio</code> file at draw.io or install the \u2018Draw.io Integration\u2019 extension for VS Code. Complete the class diagram by specifying the attributes and methods you plan to implement.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 3.</p>"},{"location":"exercises/01/ex01/#task-2-implement-the-class","title":"Task 2: Implement the Class","text":"<p>Using your class diagram as a guide, implement the <code>Circle</code> class in Python.</p>"},{"location":"exercises/01/ex01/#task-3-implement-the-__str__-method","title":"Task 3: Implement the <code>__str__</code> Method","text":"<p>Try printing an instance of your <code>Circle</code> object. You\u2019ll likely see something like:</p> <pre><code>&lt;__main__.Circle object at 0x000001E558684410&gt;\n</code></pre> <p>This default output isn\u2019t informative, as it only displays the object\u2019s memory address. Fortunately, Python provides a special method called <code>__str__</code>, which lets you customize how your object is displayed when printed.</p> <p>Modify your <code>Circle</code> class by implementing the <code>__str__</code> method so that printing a circle displays something like:</p> <pre><code>Circle with radius 5.00; diameter 10.00; area 78.54 \n</code></pre>"},{"location":"exercises/02/ex02/","title":"Exercise 2: Car","text":"<p>In this exercise, you will refactor poorly written code to better follow the Information Hiding and Tell Don\u2019t Ask principles. The scenario involves solving a simple physics problem.</p>"},{"location":"exercises/02/ex02/#brief","title":"Brief","text":"<p>Suppose a car starts from rest at position 0 meters with an initial speed of 0 m/s. John gets into the car and presses the gas pedal, causing the car to accelerate at a constant rate of 2 m/s\u00b2 for 5 seconds. From t=6 to t=8s, he maintains the current speed, applying neither acceleration nor deceleration (assume that there is no friction or air resistance). Finally, at 9 seconds, he steps on the brakes that has a breaking power of 8 m/s\u00b2.</p> <p>Determine the the nearest second at which the car comes to a complete stop and tabulate the car\u2019s position and speed at each second from t = 0 to the moment it stops. </p> <p>Model your car object such that each action takes 1 unit of time.</p>"},{"location":"exercises/02/ex02/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub.</p>"},{"location":"exercises/02/ex02/#task-1-study-the-existing-code","title":"Task 1: Study the Existing Code","text":"<p>Study the provided poorly written OOP code to understand how it works and identify areas for improvement.</p>"},{"location":"exercises/02/ex02/#task-2-design-your-class","title":"Task 2: Design Your Class","text":"<p>Open the <code>classes.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code. Create a class diagram for the <code>Car</code> class, specifying its attributes and methods. Ensure that your design follows the principles of Information Hiding and Tell Don\u2019t Ask.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 3.</p>"},{"location":"exercises/02/ex02/#task-3-implementation","title":"Task 3: Implementation","text":"<p>Refactor and rewrite the program using your class diagram.  Implement the new <code>Car</code> class so that it adheres to the Information Hiding and Tell Don\u2019t Ask principles.</p>"},{"location":"exercises/03/ex03/","title":"Exercise 3: Circle with Coordinates","text":"<p>This exercise will help you understand composition in object-oriented programming by modeling geometric objects in a 2D Cartesian plane. Specifically, we will be focusing on the <code>Circle</code> class from exercise 01. </p> <p>You will also explore how Python handles primitive and reference types and some things to take note of.</p>"},{"location":"exercises/03/ex03/#brief","title":"Brief","text":"<p>Previously, you learned how to model a simple shape like a <code>Circle</code> using classes. Now, you will extend this circle and place it in 2D Cartesian (x-y) plane. This means each shape must also keep track of its position in the x-y plane. </p> <p> Above is an image of a circle with the circle point (0,0) and a radius of 10. </p>"},{"location":"exercises/03/ex03/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/03/ex03/#task-1-primitive-vs-reference-types","title":"Task 1: Primitive vs Reference Types","text":"<p>Open the file <code>task1.py</code> and write a short code example that demonstrates how Python handles:</p> <ul> <li>Primitive types (e.g., <code>int</code>, <code>float</code>)</li> <li>Reference types (e.g., <code>list</code>, <code>dict</code>, or your own class)</li> </ul> <p>Implement functions that show how assignment and modification affect the original variables for both primitive and reference types.</p>"},{"location":"exercises/03/ex03/#task-2-point-class","title":"Task 2: <code>Point</code> Class","text":"<p>Rather than keeping track of x,y coordinate individually with our shapes using attribute for each shape, we will create a dedicated <code>Point</code> class that encapsulate the coordinate and the related logic for us.</p>"},{"location":"exercises/03/ex03/#design","title":"Design","text":"<p>Start by creating a <code>Point</code> class with these specifications:</p> <p>Attributes:</p> <ul> <li><code>x</code> (float): The x-coordinate.</li> <li><code>y</code> (float): The y-coordinate.</li> </ul> <p>Methods:</p> <ul> <li><code>distance_to(other)</code>: Returns the Euclidean distance between this point and another <code>Point</code> object.</li> <li><code>__str__</code>: Returns a string representation in the format <code>(x, y)</code>.</li> </ul>"},{"location":"exercises/03/ex03/#__eq__-method","title":"<code>__eq__</code> method","text":"<p>Before you continue to task 3, let us explore the following code:</p> <pre><code>p1 = Point(0,0)\np2 = Point(0,0)\n\nprint(p1 == p2)\n</code></pre> <p>Even though both p1 and p2 at at (0,0), the output of this code will be false! </p> <p>By default if you do not implement the <code>__eq__</code> method in python, python will compare whether the object are the same if they have same reference (location in memory). Since, p1 and p2 has different reference (as they are 2 separate object located in different area of the computer memory) it return false. </p> <p>On the other hand, something like <pre><code>p1 = Point(0,0)\np2 = p1\n\nprint(p1 == p2)\n</code></pre> will return true.</p> <p>Task: </p> <ul> <li>Research on the <code>__eq__</code> method and implement it  such that we can compare the <code>Point</code> objects using the == operator. </li> </ul>"},{"location":"exercises/03/ex03/#task-3-design-the-circle-class-using-composition","title":"Task 3: Design the <code>Circle</code> Class Using Composition","text":"<p>Redesign your <code>Circle</code> class from Exercise 1 to utilize composition by including a <code>Point</code> object as its center. </p> <p>Implement another a method such we are able to find the distance between 2 circle. Raise a ValueError if the object is not a circle (hint: use <code>isinstance(...) function</code>)</p> <p></p> <p>Note: If the circle is overlapping you should return zero. </p>"},{"location":"exercises/04/ex04/","title":"Exercise 4: Currency Converter","text":""},{"location":"exercises/04/ex04/#brief","title":"Brief","text":"<p>Previously, you learned how to build simple classes with instance attributes and methods. Now, you will work on a class that makes use of class-level state a concept where the same value is shared across all instances of a class.</p> <p>This exercise will help you understand how to use class methods and class variables in object-oriented programming. You'll model a simple currency converter that converts SGD (Singapore Dollar) to other currencies based on a shared exchange rate.</p> <p>You will explore how a single shared rate can be updated for all instances, and how to use <code>@classmethod</code> to manage this logic.</p>"},{"location":"exercises/04/ex04/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/04/ex04/#task-1-class-variables-and-instance-methods","title":"Task 1: Class Variables and Instance Methods","text":"<p>Open the file <code>task1.py</code>. Complete the following:</p> <ol> <li>Create a class called <code>CurrencyConverter</code>.</li> <li>Add the following class variables for exchange rates:<ul> <li><code>sgd_to_usd</code> (e.g. <code>0.74</code>)</li> <li><code>sgd_to_eur</code> (e.g. <code>0.68</code>)</li> <li><code>sgd_to_jpy</code> (e.g. <code>100.2</code>)</li> </ul> </li> <li>In the constructor (<code>__init__</code>), accept an amount in SGD and store it as an instance variable <code>sgd</code>.</li> <li> <p>Write instance methods that convert to each currency:</p> <ul> <li><code>to_usd()</code></li> <li><code>to_eur()</code></li> <li><code>to_jpy()</code></li> </ul> </li> </ol> <pre><code>c = CurrencyConverter(100)\nprint(c.to_usd())  # 74.0\nprint(c.to_eur())  # 68.0\nprint(c.to_jpy())  # 10020.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-2-class-methods-for-updating-rates","title":"Task 2: Class Methods for Updating Rates","text":"<p>Sometimes, currency rates change. Instead of updating the rate for each instance, we\u2019ll update the class variable using <code>@classmethod</code>.  </p> <p>Accomplish this by adding the following class methods:</p> <ul> <li><code>set_usd_rate(cls, new_rate)</code></li> <li><code>set_eur_rate(cls, new_rate)</code></li> <li><code>set_jpy_rate(cls, new_rate)</code></li> </ul> <p>Each method should update the corresponding class variable.</p> <pre><code>c1 = CurrencyConverter(100)\nprint(c1.to_eur())  # 68.0\nCurrencyConverter.set_eur_rate(0.75)\nprint(c1.to_eur())  # 75.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-3-alternative-constructor","title":"Task 3: Alternative Constructor","text":"<p>Sometimes, we want to create a <code>CurrencyConverter</code> instance from EUR, and have it compute the SGD amount automatically based on the current exchange rate.</p> <p>Add a class method <code>from_eur(cls, eur_amount)</code> ,  <code>from_usd(cls, usd_amount)</code> and  <code>from_jpy(cls, jpy_amount)</code> that:</p> <ol> <li>Converts <code>CURR_amount</code> to SGD using the current <code>sgd_to_CURR</code> rate.</li> <li>Returns a new <code>CurrencyConverter</code> object with the computed SGD amount.</li> </ol> <pre><code>CurrencyConverter.set_eur_rate(0.75)\nc2 = CurrencyConverter.from_eur(75)\nprint(c2.sgd)       # 100.0\nprint(c2.to_eur())  # 75.0\n</code></pre>"},{"location":"exercises/05/ex05/","title":"Exercise 5: Birds of a Feather","text":"<p>In this exercise, you'll apply inheritance and method overriding to model a class hierarchy of birds. This will help you understand is-a relationships and when it makes sense to use inheritance to share and specialize behavior.</p>"},{"location":"exercises/05/ex05/#brief","title":"Brief","text":"<p>You\u2019re going to build a simple bird simulator using classes and inheritance to model a zoo's bird population. All birds share some common characteristics \u2014 like laying eggs and walking \u2014 but certain types of birds have additional abilities. For example, some birds can fly, others can swim, and some can\u2019t do either.</p> <p>Rather than duplicating code across all bird types, you\u2019ll use inheritance to model shared behavior in a base class Bird, and extend it in subclasses. </p> <p>The zoo has a bird population as follows:</p> <pre><code>1. Sparrow\n   \u2003Abilities: walk, lay egg, fly\n   \u2003Count: 2 (names: chirpy, flit)\n\n2. Penguin\n   \u2003Abilities: walk, lay egg, swim\n   \u2003Count: 2 (names: tux, pebble)\n\n3. Ostrich\n   \u2003Abilities: walk, lay egg\n   \u2003Count: 2 (names: dash, featherfoot)\n\n4. Parrot\n   \u2003Abilities: walk, lay egg, fly, mimic\n   \u2003Count: 2 (names: kiwi, echo)\n</code></pre> <p>Calling each action (e.g. <code>walk()</code>) should print something like: <pre><code>flit (Parrot) walks\nflit (Parrot) lays an egg\nflit (Parrot) flies\nflit (Parrot) mimic a sound \n</code></pre></p>"},{"location":"exercises/05/ex05/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/05/ex05/#task-1-complete-class-diagram","title":"Task 1: Complete class diagram","text":"<p>Open the <code>class.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code. Complete the class diagram for the all of the classes, specifying its attributes, methods and relationship. </p> <p>You should think of 2 suitable subclasses that help better model the relationship of the <code>Parrot</code>, <code>Ostrich</code> , <code>Penguin</code> , <code>Sparrow</code> classes. The base bird class has been completed for you. Override and add the required methods for your subclass.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 3.</p>"},{"location":"exercises/05/ex05/#task-2-implement-the-code","title":"Task 2: Implement the code","text":"<p>Implement by following the class diagram above.</p>"},{"location":"exercises/05/ex05/#task-3-zoo-simulation","title":"Task 3: Zoo Simulation","text":"<p>Create a Zoo class that will manage the bird population.</p> <p>Requirements:    - Store each bird as an instance of its appropriate class    - New birds can be added birds to the zoo    - The Zoo should have a method display_all_actions that calls all the actions available for each bird in the zoo.</p> <p>Update your <code>classes.drawio</code> diagram.</p> <pre><code>Example Output:\nchirpy (Sparrow) walks\nchirpy (Sparrow) lays an egg\nchirpy (Sparrow) flies\nflit (Parrot) walks\nflit (Parrot) lays an egg\nflit (Parrot) flies\nflit (Parrot) mimic a sound \n...\n</code></pre>"},{"location":"exercises/05/ex05/#task-4-duckly-duck-multiple-inheritance","title":"Task 4: Duckly Duck \u2014 Multiple Inheritance","text":"<p>One of the zoo's new arrivals is a very special bird: Duckly. Duckly can not only walk, lay eggs, swim, fly and also quack!</p> <p>Create a new class <code>Duck</code> and use multiple inheritance in python to model Duckly\u2019s behavior. Update the class diagram and research on how multiple inheritance works in python. Add the Duckly to the Zoo.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is multiple inheritance in Python, and how is it different from single inheritance?</li> <li>What is the Method Resolution Order (MRO), and how does Python determine which method to call when multiple classes define the same method?</li> <li>Why might using multiple inheritance lead to ambiguity or conflicts? Can you give an example where this might happen?</li> <li>How does Python's super() function behave in a class that uses multiple inheritance? How can it help reduce code duplication?</li> </ol>"},{"location":"exercises/06/ex06/","title":"Exercise 6: Messenger","text":""},{"location":"exercises/06/ex06/#brief","title":"Brief","text":"<p>You're tasked with writing a <code>Messenger</code> class that sends messages to recipients in different formats and via different methods. The message can vary depending on the amount of information provided by the user, such as the type of message (SMS, Email, App), an optional subject, attachments, or priority levels.</p> <p>In this task, your goal is to refactor the provided <code>Messenger</code> class so that it only contains one <code>send</code> method, which can handle all possible combinations of information. You'll use default parameters and Python's flexibility with arguments to simplify the process and avoid code duplication.</p>"},{"location":"exercises/06/ex06/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/06/ex06/#task-1-refactor-the-messenger-class","title":"Task 1: Refactor the Messenger Class","text":"<p>The initial Messenger class contains multiple methods for each combination of information. Refactor it so that there is only one method <code>send</code> that can handle all cases based on the provided arguments.</p>"},{"location":"exercises/06/ex06/#task-2-test-and-submit","title":"Task 2: Test and Submit","text":"<ol> <li>After implementing the <code>send</code> method, write a few test in <code>main.py</code> cases to ensure your code works as expected.</li> <li>Test edge cases like:</li> <li>No optional arguments.</li> <li>Only subject or attachment passed.</li> <li>Only priority passed.</li> </ol>"},{"location":"exercises/07/ex07/","title":"Exercise 7: Birds of a Feather 2","text":""},{"location":"exercises/07/ex07/#brief","title":"Brief","text":"<p>In Exercise 5, we implemented some birds such as <code>Parrot</code> and <code>Penguin</code>. However, some of these classes should not directly be initialized. Using what you learnt about abstract classes in Unit 07,  determine which class should be abstract and convert them to abstract.</p> <p>You will be provided with the suggested solution to Exercise 5 as a starting point.</p>"},{"location":"exercises/07/ex07/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the GitHub Classroom link provided.</p>"},{"location":"exercises/07/ex07/#task-1-abstract-demo-method-abstract-class","title":"Task 1: Abstract <code>demo()</code> method &amp; Abstract Class","text":"<p>Implement the an method <code>demo</code> that must be available in all type bird. It should demonstrate all the abilities of the bird. </p> <p>For example a demo method for <code>Parrot</code> should call the following method:</p> <ul> <li>lay_egg()</li> <li>walk()</li> <li>fly()</li> <li>mimic()</li> </ul> <p>Before working on the code, complete the class diagram following the instructions below: 1. Open the <code>class.drawio</code> file using draw.io or the \"Draw.io Integration\" extension in VS Code. 2. Update the class diagram:    - Identify which classes should be abstract.    - Clearly mark abstract classes and abstract methods in the diagram (by ltalicize the class name &amp; method)</p> <p></p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 2.</p>"},{"location":"exercises/07/ex07/#task-2-refactor-the-code","title":"Task 2: Refactor the Code","text":"<p>Refactor the provided code to use abstract classes:</p> <ul> <li>Use Python\u2019s <code>abc</code> module to define abstract base classes and abstract methods.</li> <li>Ensure that all subclasses correctly implement the required abstract methods.</li> <li>The <code>Zoo</code> should now utilize the <code>demo</code> method for all birds.</li> </ul>"},{"location":"notes/01/basics/","title":"Unit 01: Basics","text":""},{"location":"notes/01/basics/#the-3-rectangles-problem","title":"The 3 Rectangles Problem","text":"<p>Let\u2019s dive right in with an example. Suppose we have three rectangles as shown in the figure below and we would like to find the area and perimeter of each rectangle.</p> <p></p>"},{"location":"notes/01/basics/#the-naive-approach","title":"The Naive Approach","text":"<p>A straightforward approach to this problem is to represent each rectangle as a tuple containing its base and height, and store these tuples in a list. To compute the area and perimeter of each rectangle, we extract the base and height from each tuple and apply the following formulas:</p> <ul> <li>Area = base \u00d7 height</li> <li>Perimeter = 2 \u00d7 (base + height)</li> </ul> <pre><code>rectangles = [(1, 2), (3, 4), (5, 6)]\n\nrect: tuple\nfor i, rect in enumerate(rectangles):\n    base, height = rect\n    area = base * height\n    perimeter = 2 * (base + height)\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre>"},{"location":"notes/01/basics/#the-oop-approach","title":"The OOP Approach","text":"<p>Now, let's see how using objects can simplify this problem!</p> Step 1: CreateStep 2: Ask <p>Instead of using tuples, we create instances of a <code>Rectangle</code> class.</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n</code></pre> <p>Rather than manually calculating the area and perimeter, we simply ask each object for its area and perimeter!</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n\nrect: Rectangle\nfor i, rect in enumerate(rectangles):\n    area = rect.area()\n    perimeter = rect.perimeter()\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre> <p>Key Takeaway</p> <p>Notice the difference? In the OOP approach, we don\u2019t need to know the formulas for area and perimeter - the logic for those are encapsulated within the object. This demonstrates two key principles of OOP: abstraction and encapsulation. </p> <p>Abstraction means hiding complex implementation details and exposing only what\u2019s essential to the user. This makes code easier to read, maintain, and reuse, while reducing complexity as programs grow. Just as high-level languages abstract away machine code, OOP lets you focus on what objects do, not how they do it.</p> <p>In fact, you\u2019ve already been using objects all along. In Python, almost everything is an object. Perhaps the object you have used the most and is familiar to you are strings; python strings are objects, and you likely have used methods the string object methods like isalpha(), isdigit() and so on. </p> <p>Have you ever wondered how those methods are actually implemented under the hood? Did you actually need to know how it works under the hood?</p>"},{"location":"notes/01/basics/#creating-the-rectangle-class","title":"Creating the <code>Rectangle</code> Class","text":"<p>So far, we\u2019ve only discussed how to use a <code>Rectangle</code> class, but how do we actually create one?</p> Step 1: DeclarationStep 2: Attributes and ConstructorStep 3: Methods <p>We start by declaring the class we want to create.</p> <pre><code>class Rectangle:\n    ...\n</code></pre> <p>Next, we define a special method called <code>__init__</code>, known as the constructor. The constructor is automatically called when a new instance of the class is created. Here, we set up the initial state of the object by assigning values to its attributes.</p> <p>Attributes are variables that belong to an object and describe its properties. For a rectangle, we need its base and height, so we give it two attributes: <code>base</code> and <code>height</code>.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):   # self refers to the instance being created\n        self.base = base                # Save the base value in the instance\n        self.height = height\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5) # Creating a rectangle instance: this internally calls Rectangle.__init__(10, 5)\n</code></pre> <p>Class vs Instance</p> <p>Declaring a class defines the blueprint for creating objects. An instance is an actual object created from that blueprint.</p> <p>Finally, we implement the methods that provide the desired behaviors for our object.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return 2 * (self.base + self.height)\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5)\n    rect1.area()                # returns 50\n    rect1.perimeter()           # returns 30\n</code></pre>"},{"location":"notes/01/basics/#class-diagram","title":"Class Diagram","text":"<p>To help visualize classes, we often use a class diagram. A class diagram provides a concise overview of all the attributes and methods a class contains.</p> <p></p> <p>In the diagram above is the class diagram for <code>Rectangle</code>. It typically consists of 2 rows where:</p> <ul> <li>The first row lists the attributes and their data types.</li> <li>The second row lists the method signatures and their return types.</li> </ul> <p>Discussion</p> <p>Discussion questions (please discuss these with your teacher!):</p> <ol> <li> <p>What is the difference between a class and an instance of a class?</p> </li> <li> <p>What does it mean to say that a class abstracts something, and why is abstraction useful in programming?</p> </li> <li> <p>What does the <code>self</code> keyword refer to?</p> </li> </ol> <p>Jump to exercise 01</p>"},{"location":"notes/02/information-hiding/","title":"Unit 02: Information Hiding","text":""},{"location":"notes/02/information-hiding/#abstraction-layer","title":"Abstraction Layer","text":"<p>Building on Unit 1, another fundamental aspect of good object-oriented design is the principle of information hiding and maintaining the abstraction layer.</p> <p>In Python, there are fewer restrictions are enforced compared to other OOP focused language like Java. This means it's easier to accidentally (or even intentionally) bypass the abstraction layer when working with OOP code. Hence, it's your responsibility to respect and protect this boundary.</p> <p>Violating the abstraction layer often leads to a phenomenon known as \"spaghetti code\" - code that is so tangled and interdependent that even small changes can break your entire program.</p> <p></p>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-car-correctness","title":"Breaking the Abstraction Layer: Car (Correctness)","text":"<p>To understand what it means to break an abstraction layer, let's consider the following <code>Car</code> class:</p> <pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self.position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self.position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self.position += distance\n</code></pre> <p>This class model a simple car driving along a 1D road. You move the car by calling the <code>drive()</code> method, which updates its position by a given distance.</p> \u2705 Correct Usage (Abstraction Maintained)\u274c Broken Abstraction Layer <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car1.drive(10)\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This is the proper way to use the <code>Car</code> class. We instruct the car to drive, and let the internal logic handles the position update to the car instance.</p> <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car.position = car.position + 10\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Instead of tell the car to drive like before, you\u2019re essentially now stepping out of the car and pushing the car manually</p> <p>Imagine trying to drive a car, only for someone else to randomly push it from the outside! Likewise, directly changing attributes can lead to unpredictable or buggy behavior.</p> <p>Tell, Don\u2019t Ask</p> <p>This example also breaks the \"Tell, Don\u2019t Ask\" principle, another core OOP principle which state that we should tell object to what to do instead of asking for information and doing it ourself. </p> <ul> <li>\u2705 Correct: <code>car.drive(10)</code> \u2192 You instruct the car itself to move.</li> <li>\u274c Incorrect: <code>car.position = car.position + 10</code> \u2192 You ask for the car\u2019s position and change it manually.</li> </ul>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-rectangle-maintainability","title":"Breaking the Abstraction Layer: Rectangle (Maintainability)","text":"<p>Preserving the abstraction layer also makes your code easier to maintain and refactor if you like to make changes to it in the future. </p> <p>Let\u2019s revisit the <code>Rectangle</code> class from Unit 01:</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>Suppose that you initially calculated area and perimeter by accessing the class fields directly and broken the abstraction layer:</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.base * rect1.height                # 50\n    perimeter = 2 * (rect1.base + rect1.height)     # 30\n</code></pre> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.area()                             # 50\n    perimeter = rect1.perimeter()                   # 30\n</code></pre> <p>Later, you might decide to represent a rectangle using its <code>base</code> and <code>area</code> instead of <code>height</code>. After all, only two of the three (base, height, area) are needed to compute the third - making this redesign valid.</p> New ClassOriginal Class <pre><code>class Rectangle:\n    def __init__(self, base, area):  \n        self.base = base               \n        self.area = area\n\n    def area(self):\n        return self.area\n\n    def perimeter(self):\n        return self.base * 2 + (self.area / self.base) * 2\n</code></pre> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>If you previously accessed fields directly, your main program will break after this internal change:</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.base * rect1.height                # \u274c Broken\n    perimeter = 2 * (rect1.base + rect1.height)     # \u274c Broken\n</code></pre> <p>The <code>height</code> attribute no longer exists, so these lines now cause errors. Whereas compared to using the class\u2019s methods (the abstraction layer), your code continues to work even after the internal changes to your class!</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.area()                             # \u2705 Still works\n    perimeter = rect1.perimeter()                   # \u2705 Still works\n</code></pre>"},{"location":"notes/02/information-hiding/#underscore-_-in-python","title":"Underscore _ in Python","text":"<p>To help preserve information hiding, Python provides a naming convention using the underscore (_) prefix to signal that a class attribute or method is meant for internal use only. </p> <p>While Python doesn't enforce access restrictions like private or protected keywords in other languages (e.g., Java or C++), the underscore acts as a convention that you - as programmers - should respect.</p> <p>Let\u2019s revise our earlier Car and Rectangle classes to follow this convention:</p> Revised Rectangle ClassRevised Car Class <p><pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self._base = base               \n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return self._base * 2 + self._height * 2\n</code></pre> We\u2019ve marked _base and _height as internal attributes, which means any calculations or logic outside this class should go through its public methods like area() or perimeter().</p> <p>Note that in the class diagram the <code>+</code> sign is also flipped to <code>-</code> to indicate that it is a private/internal field.</p> <p></p> <p><pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self._position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self._position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self._position += distance\n</code></pre> Likewise, _position is marked as internal. You\u2019re signaling to others (and to yourself) that the car\u2019s position should only be changed using drive(), and not accessed directly from outside.</p> <p>Using underscore naming convention</p> <p>Starting now, ALL of your attribute in your class should be internal by default. You almost should never even use public attributes.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teaching assistant!)</p> <ol> <li>What is the difference between accessing an attribute directly vs using a method? Why might direct access lead to problems in larger programs?</li> <li>Consider the principle \u201cTell, Don\u2019t Ask.\u201d Why might this lead to better object-oriented code?</li> <li>How does changing the internal implementation of a class (e.g., switching from height to area in <code>Rectangle</code>) illustrate the value of abstraction?</li> <li>Why should we use underscore in attributes and methods?</li> </ol> <p>Jump to exercise 02</p>"},{"location":"notes/03/composition/","title":"Unit 03: Composition","text":""},{"location":"notes/03/composition/#car","title":"Car","text":"<p>In Object-Oriented Programming (OOP), composition is another fundamental design principle whereby we construct objects from other objects. This allows you to build complex systems flexibly, by combining simpler, well-defined components. </p> <p>To illustrate composition, let\u2019s build on our car example from Unit 02</p>"},{"location":"notes/03/composition/#separate-classes-for-engine-and-brake","title":"Separate Classes for Engine and Brake","text":"<p>A real car has an engine system and has a brake system. Instead of bundling these directly into the <code>Car</code>, we can create distinct classes for each. </p> EngineBrake <p>The <code>Engine</code> class models an engine that can be started or stopped, and calculates acceleration based on how much you press the pedal.</p> <pre><code>class Engine:\n\n    def __init__(self, max_acceleration: float) -&gt; None:\n        self._max_acceleration: float = max_acceleration\n        self._is_on: bool = False\n\n    def start(self) -&gt; None:\n        self._is_on = True\n\n    def stop(self) -&gt; None: \n        self._is_on = False\n\n    def is_running(self) -&gt; bool:\n        return self._is_on\n\n    def apply(self, paddle_ratio) -&gt; float:\n        if paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        if not self.is_running() and paddle_ratio &gt; 0:\n            raise Exception(\"The engine cannot accelerate when it is stopped.\")\n\n        return self._max_acceleration * paddle_ratio\n</code></pre> <p>The <code>Brake</code> class simulates how a brake gets worn down with use and calculates braking force accordingly.</p> <pre><code>class Brake:\n\n    def __init__(self, max_deceleration: float):\n        self._max_deceleration: float = max_deceleration\n        self._wear: float = 0                   \n\n    def apply(self, paddle_ratio: float) -&gt; float:\n        if paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        self._wear += 0.00001 * paddle_ratio    \n        # Braking effect reduces as wear increases, and is always negative (slows the car)\n        return self._max_deceleration * paddle_ratio * max(self._wear, 0.1) * -1\n</code></pre>"},{"location":"notes/03/composition/#composing-engine-and-brake-in-car","title":"Composing Engine and Brake in Car","text":"<p>By using the <code>Engine</code> and <code>Brake</code> objects inside the new <code>Car</code> class, we achieved composition:</p> <pre><code>class Car:\n    def __init__(self, start_pos: float, engine: Engine, brake: Brake) -&gt; None:\n        self._position: float = start_pos\n        self._speed = 0\n\n        self._engine: Engine = engine\n        self._brake: Brake = brake\n\n    def start(self) -&gt; None:\n        self._engine.start()\n\n    def stop(self) -&gt; None:\n        self._engine.stop()\n\n    def _accelerate(self, acceleration: float) -&gt; None:\n        # Internal method: should not be called directly from outside this class\n        dt = 1.0\n        v0 = self._speed\n        v1 = max(v0 + acceleration * dt, 0)\n        dx = 0.5 * (v0 + v1) * dt\n\n        self._speed = v1 \n        self._position += dx\n\n    def drive(self, paddle_ratio: float) -&gt; None:\n        acceleration = self._engine.apply(paddle_ratio)\n        self._accelerate(acceleration)\n\n    def brake(self, paddle_ratio: float) -&gt; None:\n        deceleration = self._brake.apply(paddle_ratio) # this is negative\n        self._accelerate(deceleration)\n</code></pre>"},{"location":"notes/03/composition/#class-diagram","title":"Class Diagram","text":"<p>The class diagram for the <code>Car</code> class looks like this:</p> <p></p> <p>The diamond-shaped arrows represents a 'has-a' relationship between objects</p>"},{"location":"notes/03/composition/#dangers-of-composition-references-aliasing","title":"Dangers of Composition: References / Aliasing","text":"<p>As objects in python are reference types, a possible danger with composition in Python come with aliasing that may lead to unintended side effect. </p> <p>Study the code below. What do you expect to happen here and why? (hint: a line will throw an error) </p> ExampleAnswer: Part 1Answer: Part 2 <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    ...\n</code></pre> <p>The above example, we only created one engine object which both object are referencing. In other words, both cars are sharing one engine.</p> <pre><code>def main():\n    ...\n    car1.stop()          # Stops the engine for BOTH car1 and car2\n    car2.drive(0.3)      # This will raise an Exception: \"The engine cannot accelerate when it is stopped\"\n    ...\n</code></pre> <p>Thus, when <code>car1.stop()</code> is called, it shuts down the shared engine. So, even though you're calling <code>car2.drive(0.3)</code> next, the engine is already stopped-triggering an exception.</p> <p>Unintended side effects</p> <p>When you pass objects in Python, you are passing references to the actual objects and not creating copies (unlike with primitive types like <code>int</code>, <code>float</code>, or <code>str</code>). Always be mindful of this, especially when composing objects as sharing objects (aliasing) can have unintended side effects if not managed carefully!</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What are the benefits of using composition instead of putting all functionality directly inside the Car class?</li> <li>What is object aliasing and why do you think it may make debugging harder in huge codebases systems?</li> <li>Why is _accelerate() marked with an underscore in the Car class? Should you call it from outside the class? Why or why not?</li> </ol> <p>Jump to exercise 03</p>"},{"location":"notes/04/class-field-method/","title":"Unit 04: Class Fields and Methods","text":"<p>Using the <code>Rectangle</code> class from Unit 01, this unit will introduce you to the difference between instance and class variables, as well as instance and class methods.</p>"},{"location":"notes/04/class-field-method/#variables","title":"Variables","text":"<p>In this section we will look the difference between instance and class variables </p>"},{"location":"notes/04/class-field-method/#instance-variables","title":"Instance Variables","text":"<p>As a recap, instance variables are used to store data unique to each object. They are defined with <code>self</code> inside the <code>__init__</code> constructor and belong to each specific instance of a class.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base         # instance variable\n        self._height = height     # instance variable\n\n    ...\n</code></pre> <p>Every <code>Rectangle</code> object instance has its own <code>base</code> and <code>height</code>, so changes to one object\u2019s instance variables won\u2019t affect others.</p>"},{"location":"notes/04/class-field-method/#class-variables","title":"Class Variables","text":"<p>In contrast, class variables are shared among all instances of a class. They are typically used for properties that should be consistent for every object, or to keep track of class-level information.</p> <p>For example, all rectangles have four sides, and you may want to count how many rectangles have been created:</p> <pre><code>class Rectangle:\n    SIDES = 4               # class variable (constant)\n    _count = 0              # class variable (for tracking)\n\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n        Rectangle._count += 1    # update class variable\n\n    ...\n</code></pre> <p>No matter how many <code>Rectangle</code> objects you create, both <code>SIDES</code> and <code>count</code> are shared and accessible from every instance and through the class itself.</p>"},{"location":"notes/04/class-field-method/#methods","title":"Methods","text":"<p>In this section we will look the difference between instance and class methods. </p>"},{"location":"notes/04/class-field-method/#instance-methods","title":"Instance Methods","text":"<p>Like instance variables, instance methods operate on individual objects and can access or modify instance variables. In Python, they always take <code>self</code> as their first parameter.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):                     # instance method\n        return self._base * self._height\n\n    ...\n</code></pre>"},{"location":"notes/04/class-field-method/#class-methods","title":"Class Methods","text":"<p>Similarly, class methods are used for operations that affect the class as a whole, not specific instances. They are defined with the <code>@classmethod</code> decorator and take <code>cls</code> as their first parameter.</p> <pre><code>class Rectangle:\n    _count = 0\n\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n        Rectangle._count += 1\n\n    @classmethod\n    def how_many(cls):              # class method\n        return cls._count           # cls here is Rectangle\n</code></pre> <p>Limited Access</p> <p>Class methods cannot access instance variables (since they don\u2019t have access to <code>self</code>), but can access class variables and other class methods.</p>"},{"location":"notes/04/class-field-method/#summary","title":"Summary","text":"<p>Summary Table</p> Field/Method Type How to Define Belongs To First Parameter Can Access Use Case Instance variable <code>self.base</code> Instance - Instance Data unique to each object Instance method <code>def area(self):</code> Instance <code>self</code> Instance Behavior based on instance attributes Class variable <code>count = 0</code> Class - Class Data shared by all instances Class method <code>@classmethod</code> Class <code>cls</code> Class Behavior related to the class itself <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is the difference between class and instance methods/variables?</li> <li>When do we use class methods/variables?</li> </ol> <p>Jump to exercise 04</p>"},{"location":"notes/05/subclasses/","title":"Unit 05: Inheritance and Subclasses","text":"<p>In Unit 03, we looked at how we can build complex classes using composition \u2014 that is, combining smaller classes together to model a has-a relationship. Now, we\u2019ll look at how to model an is-a relationship between classes using inheritance!</p>"},{"location":"notes/05/subclasses/#square-rectangle","title":"Square &amp; Rectangle","text":""},{"location":"notes/05/subclasses/#creating-a-square","title":"Creating a Square","text":"<p>Suppose we want to create a new class called Square. We might start off implementing it like this:</p> <pre><code>class Square:\n    def __init__(self, length):\n        self._base = length\n        self._height = length\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <p>Looks familiar, right? It\u2019s basically the exact same code as our Rectangle class from Unit 01. That\u2019s because a square is really just a special case of a rectangle \u2014 it\u2019s a rectangle where the base and height are equal. So we can say that a Square is a Rectangle \u2014 it\u2019s a subset of rectangles.</p> <p>In other words, a Square is-a Rectangle.</p> <p></p>"},{"location":"notes/05/subclasses/#inheriting-a-rectangle","title":"Inheriting a Rectangle","text":"<p>Instead of rewriting all of Rectangle\u2019s code in Square, we can use inheritance to reuse it:</p> New SquareRectangle <pre><code>class Square(Rectangle):                      # This tells Python that Square inherits from Rectangle\n    def __init__(self, length):\n        super().__init__(length, length)      # super() means \"call the parent class\", so this runs Rectangle's __init__\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Just like that, we're done! Square now has access to all the methods in Rectangle, automatically.</p> <p>The class diagram for this looks like:</p> <p></p> <p>Now we can say that Square is a subclass of Rectangle \u2014 or using the parent-child terminology, Square is the child and Rectangle is the parent. Or the Square extends Rectangle.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def __str__(self):\n        return f\"Rectangle with {self.get_base()} base and {self.get_height()} height\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre>"},{"location":"notes/05/subclasses/#method-overriding","title":"Method Overriding","text":"<p>You might\u2019ve noticed that we defined a <code>__str__</code> method again inside our Square class. That\u2019s called method overriding.</p> <pre><code>class Square(Rectangle):                    \n    def __init__(self, length):\n        super().__init__(length, length)    \n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>We are replacing the <code>__str__</code> method from Rectangle with a new version specific to Square.</p> Without <code>__str__</code> methodWith <code>__str__</code> method <p>If we didn\u2019t define the <code>__str__</code> method in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n</code></pre> <p>Then this code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Would give us:</p> <pre><code>Rectangle with 5 base and 5 height\n</code></pre> <p>This happens because Square didn't define its own <code>__str__</code>, so it just uses the one it inherited from Rectangle.</p> <p>But if we do define <code>__str__</code> in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Then the same code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Will now give us:</p> <pre><code>Square with 5 length\n</code></pre> <p>Here, we\u2019ve overridden the <code>__str__</code> method from Rectangle with a new one tailored for Square.</p> <p>Method Resolution Order (MRO)</p> <p>When you call a method on an object, Python doesn\u2019t just randomly guess which method it should call. Python will follows a rule called the Method Resolution Order (MRO).</p> <p>Python first checks the child class (like Square). If the method exists there, it uses it. If not, it \"moves up\" to the parent (like Rectangle) and checks there and so on. So in our case, Python sees that Square has a <code>__str__</code> method in Square, and uses it. If it didn\u2019t, it would use the one from Rectangle.</p> <p>Note: Unlike other languages, python doesn\u2019t care how many arguments the method takes \u2014 it only checks the method name to decide if the method is overridden. If a child and parent both have a method with the same name, the child\u2019s version always takes priority.</p>"},{"location":"notes/05/subclasses/#adding-methods-to-subclasses","title":"Adding Methods to Subclasses","text":"<p>On top of just inheriting methods and attributes from our parent class, we can also define new methods in the child class to extend or specialize its behavior.</p> <p>Let\u2019s go back to our Rectangle and Square example. Suppose we want the Square class to have a method that tells us whether another square can fit inside a given area. That\u2019s something specific to squares \u2014 our Rectangle class doesn\u2019t need to know about it. We can add that method directly in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n\n    def can_fit(self, other: \"Square\"):\n        if not isinstance(other, Square):\n            raise ValueError(\"can_fit only works with other Square Objects\")\n\n        return self.area() &lt;= other.area()\n</code></pre> <p>The new <code>can_fit</code> method is only available on Square, not Rectangle \u2014 and that\u2019s fine! That\u2019s the power of subclassing: we can start with shared behavior and add specific features when needed.</p> <p></p>"},{"location":"notes/05/subclasses/#negative-example-when-not-to-use-inheritance","title":"Negative example: When NOT to Use Inheritance","text":"<p>We\u2019ve learned that Square can inherit from Rectangle, because a square is a special kind of rectangle. That\u2019s an example of inheritance being used correctly \u2014 it makes sense. But not everything that shares some features should be related by inheritance. </p> <p>Let\u2019s look at a case where inheritance goes wrong. Let say we want our library to have a name attribute. So we see that book class has the _name attribute, we will make the library inherit it! </p> <p>Imagine someone wrote the following:</p> <pre><code>class Book:\n    def __init__(self, name):\n        self._name = name\n\nclass Library(Book):  # \u26a0\ufe0f Uh-oh!\n    def __init__(self, name, books):\n        super().__init__(name)\n        self._books = books\n</code></pre> <p>This looks like Library is a kind of Book. But that doesn\u2019t really make sense \u2014 a library isn\u2019t a book, it just has books. But later in the code, say we have a function that read a book:</p> <pre><code>def read(book: Book):\n\n    if not isinstance(book, Book):\n        raise ValueError(\"We can only read a book!\")\n\n    print(f'Reading: {book._name}')    # by right you should implement a getter method (i.e. get_name()) as this violate the abstraction layer / barrier \n\nread(lib)  # Wait \u2014 we\u2019re reading a library?! but our code is still working even tho we a check to ensure that we only can read books!\n</code></pre> <p>That is not right. A library isn\u2019t something you read \u2014 it contains things you read. This is an example of using inheritance just to \u201creuse\u201d the name variable from Book. But it\u2019s the wrong relationship. A library has books. It is NOT a book.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>When do we use inheritance over composition?</li> <li>What is overriding and when might it be useful to override a method in a child class?</li> <li>How does python resolve a method with the same name in both the child and parent class? If a method is not available in child class, where does Python check next?  </li> </ol> <p>Jump to exercise 05</p>"},{"location":"notes/06/overloading/","title":"Unit 06: Overloading","text":"<p>While Python does not support traditional method overloading like Java or C++, we can achieve similar behavior through the use of default arguments. In this unit, we\u2019ll explore how Python simulates overloading and how you can implement flexible method interfaces.</p>"},{"location":"notes/06/overloading/#what-is-overloading","title":"What is Overloading?","text":"<p>In many programming languages, overloading allows you to define multiple versions of the same method, each with different parameters. For example in java:</p> <pre><code>int add(int a, int b) {\n    return a + b;\n}\nint add(int a, int b, int c) {\n    return a + b + c;\n}\n</code></pre> <p>But in Python, this does not work:</p> <pre><code>def add(a, b):\n    return a + b\n\ndef add(a, b, c):  # This will override the previous `add`\n    return a + b + c\n</code></pre> <p>Only the last function definition remains. Earlier ones are replaced.</p>"},{"location":"notes/06/overloading/#simulating-overloading","title":"Simulating Overloading","text":"<p>Since Python doesn't support overloading by default, we can simulate it using flexible parameters:</p> <pre><code>def add(a, b, c=0):  # we set c with a default value of 0. \n    return a + b + c\n</code></pre> <p>Now, like the java version, this works with 2 or 3 arguments:</p> <pre><code>add(1, 2)       # 3\nadd(1, 2, 3)    # 6\n</code></pre>"},{"location":"notes/06/overloading/#when-not-to-use-overloading","title":"When NOT to Use Overloading","text":"<p>While overloading is useful, but overusing flexible parameters can make code unclear; do not have one function that does everything</p> <pre><code>def do_stuff(*args, **kwargs):\n    # ???\n</code></pre> <p>Only use overloading for method that are similar.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is overloading and why is it useful?</li> <li>Why doesn\u2019t Python allow multiple functions with the same name like Java or C++? (hint there something to do with python being a dynamically typed language)</li> <li>How does using default parameters help us simulate overloading in Python? Find a function from Python's built-in libraries that uses default parameters like this.</li> </ol> <p>Jump to exercise 06</p>"},{"location":"notes/07/abstract/","title":"Unit 07: Abstract Classes","text":"<p>Recall that with inheritance, we are modeling an \"is-a\" relationship. Abstract classes are a natural extension of inheritance \u2014 with the key difference that an abstract class relies on its child classes to implement certain methods. </p> <p>In other words, abstract classes and methods are just concept and idea of the things you are trying to model. </p>"},{"location":"notes/07/abstract/#shapes","title":"Shapes","text":"<p>Consider a <code>Rectangle</code> class and a <code>Circle</code> class:</p> RectangleCircle <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <pre><code>import math\n\nclass Circle:\n    def __init__(self, radius: float):\n        self._radius = radius\n\n    def diameter(self):\n        return self._radius * 2\n\n    def area(self):\n        return math.pi * self._radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self._radius\n</code></pre> <p>Both classes work independently \u2014 but they share a common identity: they are both shapes.</p>"},{"location":"notes/07/abstract/#introducing-an-abstract-base-class","title":"Introducing an Abstract Base Class","text":"<p>Let\u2019s define a base class <code>Shape</code> that ensures all shapes must implement both <code>area()</code> and <code>perimeter()</code>:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n</code></pre> <p>Now, we can make both <code>Rectangle</code> and <code>Circle</code> subclasses of <code>Shape</code>:</p> RectangleCircle <pre><code>class Rectangle(Shape):\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <pre><code>import math\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self._radius = radius\n\n    def area(self):\n        return math.pi * self._radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self._radius\n</code></pre> <p>Now we can treat both as Shapes:</p> <pre><code>shapes = [Rectangle(4, 5), Circle(3)]\n\nfor shape in shapes:\n    print(f'is a Shape?: {isinstance(shape, Shape):.2f}')\n    print(f'Area: {shape.area():.2f}')\n    print(f'Perimeter: {shape.perimeter():.2f}')\n</code></pre>"},{"location":"notes/07/abstract/#what-happens-if-a-method-isnt-implemented","title":"What Happens If a Method Isn't Implemented?","text":""},{"location":"notes/07/abstract/#missing-implementation","title":"Missing implementation","text":"<p>Let\u2019s say we define a subclass that forgets to implement all the required methods:</p> <pre><code>class IncompleteShape(Shape):\n    def area(self):\n        return 0\n</code></pre> <p>This is missing the implementation for the <code>perimeter()</code> method, so trying to instantiate it:</p> <pre><code>shape = IncompleteShape()\n</code></pre> <p>Raises a <code>TypeError</code>:</p> <pre><code>TypeError: Can't instantiate abstract class IncompleteShape with abstract method perimeter\n</code></pre> <p>Python prevents you from creating objects from incomplete subclasses.</p>"},{"location":"notes/07/abstract/#instantiating-an-abstract-class","title":"Instantiating an abstract class","text":"<p>Likewise,  <pre><code>shape = Shape()     # a shape is a shape!\n</code></pre> will not work as well. You cannot instantiate abstract class.</p> <p>Discussion</p> <p>Discussion questions (please discuss these with your teacher!):</p> <ol> <li>What is the purpose of an abstract base class, and how is it different from a regular parent class?</li> <li>What would happen if you tried to create an instance of the abstract <code>Shape</code> class directly?</li> <li>What happens if a subclass does not implement all of the abstract methods required by its abstract base class? Why is this behavior important? (hint: it a form of guarantee (confirm + chop))</li> </ol> <p>Jump to exercise 07</p>"}]}