{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PY2 OOP","text":"<p>Welcome to the world of Objects!</p> <p>Congratulations on making it this far. With you knowledge gained from all the 186 exercises, you're ready to explore a new programming paradigm: Object-Oriented Programming!</p> <p>Unlike the procedural approach to programming, whereby we create procedure (functions) to do repetitive task, in OOP you will be learning how to model objects (possibly real world object) using code!</p> <p>This website will host the materials: notes, exercise and project for the PY2 OOP curriculum</p>"},{"location":"exercises/01/ex01/","title":"Exercise 1: Circles","text":"<p>In this exercise, you will be creating your first class!</p>"},{"location":"exercises/01/ex01/#brief","title":"Brief","text":"<p>Suppose we have 3 circles with radius of 5, 10, 20 respectively. Model the circles as a object such that we can find the diameter, area and parameter of each circle</p> <p></p>"},{"location":"exercises/01/ex01/#task-0-accept","title":"Task 0: Accept","text":"<p>Accept the assignment from github using this link </p>"},{"location":"exercises/01/ex01/#task-1-class-diagram","title":"Task 1: Class diagram","text":"<p>Before you begin coding, open the Circle.drawio file at draw.io or install the 'Draw.io Integration' extension on vscode and fill in the class diagram containing the attribute and method that you will be implementing.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your diagram with your teacher before moving on to Task 2.</p>"},{"location":"exercises/01/ex01/#task-2-implement","title":"Task 2: Implement","text":"<p>Follow the class diagram and implement the <code>Circle</code> class</p>"},{"location":"exercises/01/ex01/#task-3-__str__-method","title":"Task 3: <code>__str__</code> method","text":"<p>Try printing the an instance of the Circle object. You would probably see and output similar to this: <pre><code>&lt;__main__.Circle object at 0x000001E558684410&gt;\n</code></pre> This isn\u2019t very useful to us. </p> <p>By default, python will print the id of the circle object (where circle object is located in our computer memory). Luckily, python provide another special method <code>__str__</code> that allow use to replace this output.</p> <p>Your task: Modify your class by implementing the <code>__str__</code> method such that it return an output similar to this:</p> <pre><code>Circle with radius 5; diameter 10\n</code></pre>"},{"location":"exercises/02/ex02/","title":"Exercise 2: Car","text":"<p>In this exercise, you will be rewriting some badly written code to follow the Information Hiding/Tell don't ask principles. This exercise involve a simple physic problem.</p>"},{"location":"exercises/02/ex02/#brief","title":"Brief","text":"<p>Suppose a car starts from rest at position 0 meters with an initial speed of 0 m/s. John gets into the car and presses the gas pedal, causing the car to accelerate at a constant rate of 2 m/s\u00b2 for 5 seconds. From t=6 to t=8s, he maintains the current speed, applying neither acceleration nor deceleration (assume that there is no friction or air resistance). Finally, at 9 seconds, he steps on the brakes that has a breaking power of 8 m/s\u00b2.</p> <p>Determine the time (the nearest second) at which the car comes to a complete stop , and tabulate the car\u2019s position and speed at each second from t = 0 to the moment it stops. Model your car object such that each action takes 1 unit of time.</p>"},{"location":"exercises/02/ex02/#task-0-accept","title":"Task 0: Accept","text":"<p>Accept the assignment from github using this link </p>"},{"location":"exercises/02/ex02/#task-1-study-the-code","title":"Task 1: Study the Code","text":"<p>Study the poorly written OOP code and figure out what is going on.</p>"},{"location":"exercises/02/ex02/#task-2-design-your-class","title":"Task 2: Design your class","text":"<p>Open the Circle.drawio file at draw.io or using 'Draw.io Integration' extension on vscode and fill in the class diagram containing the attribute and method that you will be implementing.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your diagram with your teacher before moving on</p>"},{"location":"exercises/02/ex02/#task-3-implement","title":"Task 3: Implement","text":"<p>Rewrite the program, following the class diagram and implement the new <code>Car</code> class that adhere to the Information Hiding + Tell Don't Ask principles </p>"},{"location":"exercises/03/ex03/","title":"Exercise 3: Records","text":""},{"location":"exercises/03/ex03/#brief","title":"Brief","text":"<p>For the past 20 years, the Pallet Town Veterinary Clinic has managed patient records using traditional pen-and-paper methods. As a result, the clinic\u2019s walls are now lined with stacks of folders with medical records all over the place. Although the clinic prides itself on its personalized service and dedicated staff, the ever-increasing volume of patient records has made it challenging to track information, follow up with pet owners, and deliver timely treatments.</p> <p>To modernize their operations and improve patient care, the clinic is now transitioning to a digital record system. You are tasked to to design and implement a digital records system for Pallet Town Veterinary Clinic with the following requirements: </p> <p>Each patient (i.e., a pet) record must store the following:</p> <ul> <li>Pet Information: name, species, and breed</li> <li>Owner Contact Information: name, phone number, and email address</li> <li>Medical Record: list of treatments, vaccination history, and date of last visit</li> </ul> <p>Additionally, the clinic must be able to:</p> <ul> <li>Update any part of a patient's record (e.g., owner contact details, new treatments, etc.)</li> <li>Get a list of pets that have not visited the clinic in a long time for be able to send send check-up reminder.</li> </ul> <p>You will design and implement this system using composition, where complex objects (like a patient) are made up of smaller, dedicated objects.</p>"},{"location":"exercises/03/ex03/#task-0-accept","title":"Task 0: Accept","text":"<p>Accept the assignment from github using this link </p>"},{"location":"exercises/03/ex03/#task-1-exploring-primitive-vs-reference-type","title":"Task 1: Exploring Primitive vs Reference Type","text":""},{"location":"exercises/03/ex03/#task-2-design-your-class","title":"Task 2: Design your class","text":"<p>Open the Circle.drawio file at draw.io or using 'Draw.io Integration' extension on vscode and fill in the class diagram containing the attribute and method that you will be implementing.</p> <p>Tip: Nouns and Verbs</p> <p>hint hint take notes of the nouns and verbs in the brief. </p>"},{"location":"exercises/03/ex03/#task-3-implement","title":"Task 3: Implement","text":"<p>Checkpoint: Correct diagram</p> <p>Please confirm your diagram with your teacher before staring on Task 3.</p> <p>Class Design</p> <p>Do take note that there is not 'correct' a design to this problem. So long that your design is reasonable and you are able to justify it, your design will be accepted.</p> <p>A Sample Patient Record is given below: <pre><code>Pet Information:\n    Name: Carrot\n    Species: Dog\n    Breed: Golden Retriever\n\nOwner Information:\n    Name: John doe\n    Phone: 91234567\n    Email: john.doe@example.com\n\nMedical Record:\n    Treatments:\n        - (\"Deworming\", \"2023-02-10\")\n        - (\"X-ray for hind leg\", \"2024-01-12\")\n\n    Vaccinations:\n        - (\"Rabies\", \"2023-02-10\")\n\n    Last Visit: 2024-01-12\n</code></pre></p>"},{"location":"notes/01/basics/","title":"Unit 01: Basics of OOP","text":"<p>Learning Objectives</p> <p>After completing this unit, you should be able to:</p> <ul> <li>Understand the concept of a class as a blueprint for creating objects</li> <li>Differentiate between a class and an instance of a class</li> <li>Use abstraction and encapsulation to hide internal implementation details</li> <li>Model real-world entities using classes with attributes and methods</li> <li>Write simple classes with constructors and instance methods</li> </ul>"},{"location":"notes/01/basics/#the-3-rectangles-problem","title":"The 3 Rectangles Problem","text":"<p>Let us dive straight in with an example. Suppose we have 3 rectangles as shown in the figure below. We are tasked to find the area and perimeter for each rectangle.</p> <p></p>"},{"location":"notes/01/basics/#the-naive-approach","title":"The naive approach","text":"<p>A naive approach to this problem is simply to store each rectangle as a tuple containing the base and height of a rectangle in list. To then compute the area and perimeter of each rectangle, we extract the base and height of the rectangle from each tuple and applying the following formulas for to find the area and perimeter:</p> <ul> <li>Area = base \u00d7 height</li> <li>Perimeter = 2 \u00d7 (base + height)</li> </ul> <pre><code>rectangles = [(1, 2), (3, 4), (5, 6)]\n\nrect: tuple\nfor i, rect in enumerate(rectangles):\n    base, height = rect\n    area = base * height\n    perimeter = 2 * (base + height)\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre>"},{"location":"notes/01/basics/#the-oop-approach","title":"The OOP approach","text":"<p>Now in the OOP approach, we will utilize the power of OOP to make our problem simpler! </p> Step 1: CreateStep 2: Ask <p>Instead of using tuples, we create instances of the <code>Rectangle</code> class. </p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n</code></pre> <p>Rather than calculating area and perimeter manually, we will just simply ask each object directly for its area and perimeter!</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n\nrect: Rectangle\nfor i, rect in enumerate(rectangles):\n    area = rect.area()\n    perimeter = rect.perimeter()\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre> <p>Key Takeaway</p> <p>Did you notice the difference? In the OOP approach, we don\u2019t need to actually know the formulas to calculate the area and perimeter\u2014this logic is hidden from us. This example illustrates a key principle of OOP: abstraction and encapsulation. The ultimate goal is to make our own lives easier when programming\u2014especially as we begin writing more complex programs.</p> <p>In fact, you've already been using objects constantly. In Python, almost everything is an object. Perhaps the most familiar ones to you are string methods, like those that start with <code>is...</code>, such as <code>isalpha()</code> and <code>isdigit()</code>.</p> <p>Did you ever actually know how those methods are implemented under the hood?</p>"},{"location":"notes/01/basics/#creating-the-rectangle-class","title":"Creating the <code>Rectangle</code> Class","text":"<p>So far we have only discussed how the rectangle class can be used, but how can we actually create it?</p> Step 1: DeclarationStep 2: Attributes and ConstructorsStep 3: Method <p>We will start off by declaring the class which we are looking to create. </p> <pre><code>class Rectangle:\n    ...\n</code></pre> <p>Next we use the special init function to define a constructor. A constructor is automatically called when a new instance of a class is created. This is where we can set up the initial state of the object by assigning values to its attributes.</p> <p>Attributes are variables that belong to an object. They help describe the characteristics or properties of the object. In our rectangle example, we need to know how tall and how wide it is, thus we can give it two attributes: base and height.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):   # self: refer to the instance of the object that was just created\n        self.base = base                # self.base = base saves the value inside the current instance so that we can use it later\n        self.height = height\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10,5) # Creating a rect instance: this is something like calling Rectangle.__init__(10,5)\n</code></pre> <p>Class vs instance</p> <p>When we declare a class, we are creating the template of HOW to make the object. When we talk about instance, we are dealing with the real object itself</p> <p>Finally, we will implement required method that give use the behaviors that we want from our object. </p> <pre><code>class Rectangle:\n    def __init__(self, base, height):   # self: refer to the instance of the object that was just created\n        self.base = base                # self.base = base saves the value inside the current instance so that we can use it later\n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10,5)     # Creating a rect instance: this is something like calling Rectangle.__init__(10,5)\n    rect1.area()                # returns 50\n    rect1.perimeter()           # returns 30\n</code></pre>"},{"location":"notes/01/basics/#class-diagram","title":"Class diagram","text":"<p>Often to help us visualize classes, we create something known as a class diagram. A class diagram is a concise visualization of all the attributes and method that class may have. </p> <p>The class diagram for <code>Rectangle</code> is shown:</p> <p></p> <p>Explanation:</p> <ul> <li>The first row contains attribute its respective datatype</li> <li>The second row contains it methods signature and its return type</li> </ul> <p>Discussion</p> <p>Discussion questions (please discuss this with you teaching assistant!)</p> <ol> <li> <p>What is the difference between a class and an instance of a class?</p> </li> <li> <p>What does it mean to say that a class abstracts something? and why do we want to abstract code?</p> </li> <li> <p>What does the <code>self</code> keyword refer to?</p> </li> </ol> <p>Jump to exercise 01</p>"},{"location":"notes/02/information-hiding/","title":"Unit 02: Information Hiding","text":"<p>Learning Objectives</p> <p>After completing this unit, you should be able to:</p> <ul> <li>Explain the concept of abstraction and how it applies to object-oriented programming.</li> <li>Identify and avoid violations of the abstraction layer in Python code.</li> <li>Describe the risks of directly accessing or modifying object attributes.</li> <li>Refactor code to preserve the abstraction layer, improving maintainability and flexibility.</li> <li>Apply the \"Tell, Don\u2019t Ask\" principle to design better class interactions.</li> </ul>"},{"location":"notes/02/information-hiding/#abstraction-layer","title":"Abstraction Layer","text":"<p>Continuing from Unit 1, another key aspect of good object-oriented design is hiding away information and maintaining the abstraction layer. </p> <p>In Python, unlike some other languages, there are fewer enforced restrictions. This makes it easier to accidentally (or intentionally) bypass the abstraction layer - making it your responsibility as a programmer to not violate this principle.</p> <p>Breaking the abstraction layer often lead to a symptoms known as 'spaghetti' code where your code is so intertwined that changing a small part break your whole program.</p> <p></p>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-car-correctness","title":"Breaking the Abstraction Layer: Car (Correctness)","text":"<p>To understand what it means to break an abstraction layer, let's consider the following <code>Car</code> class:</p> <pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self.position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self.position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self.position += distance\n</code></pre> <p>This class models a simple car moving along a 1D road. The <code>drive()</code> method allows the car to move by a certain distance.</p> \u2705 Correct Usage (Abstraction Maintained)\u274c Broken Abstraction Layer <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car1.drive(10)\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This is the proper way to use the <code>Car</code> class. We instruct the car to drive, and the internal logic handles the position update to the car instance.</p> <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car1.position += 10\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>As you may have noticed in Exercise 1, it's possible to directly modify a class's attributes. However, doing so breaks the abstraction layer. </p> <p>Instead of tell the car to drive like before, you\u2019re essentially now stepping out of the car and pushing the car manually. Imagine trying to drive a car and being randomly pushed around (breaking the abstraction layer is a huge reason behind buggy code).</p> <p>Tell, Don\u2019t Ask</p> <p>The broken example above also violates another fundamental object-oriented design principle: \"Tell, Don\u2019t Ask\". This principle means that you should tell objects what to do instead of asking for their state and doing it yourself.</p> <ul> <li>\u2705 Correct: car.drive(10) \u2192 You tell the car to move.</li> <li>\u274c Incorrect: car.position += 10 \u2192 You ask for the car\u2019s position and change it manually.</li> </ul>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-rectangle-maintainability","title":"Breaking the Abstraction Layer: Rectangle (Maintainability)","text":"<p>Another reason to preserve the abstraction layer is that it makes your code much easier to maintain or refactor if you like to make change to it in the future. Let\u2019s revisit the <code>Rectangle</code> class from Unit 01. </p> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>Suppose we initially violated the abstraction layer to compute area and perimeter:</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.base * rect1.height                # 50\n    perimeter = 2 * (rect1.base + rect1.height)     # 30\n</code></pre> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.area()                             # 50\n    perimeter = rect1.perimeter()                   # 30\n</code></pre> <p>Later on, you may decide to represent a rectangle using <code>base</code> and <code>area</code> instead of <code>height</code>. After all, you only need two of the three (base, height, area) to compute the third, making this redesign valid.</p> New ClassOriginal Class <pre><code>class Rectangle:\n    def __init__(self, base, area):  \n        self.base = base               \n        self.area = area\n\n    def area(self):\n        return self.area\n\n    def perimeter(self):\n        return self.base * 2 + (self.area / self.base) * 2\n</code></pre> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>However, making this redesign breaks your main program if you had broken the abstraction layer earlier on!</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.base * rect1.height                # \u274c Broken\n    perimeter = 2 * (rect1.base + rect1.height)     # \u274c Broken\n</code></pre> <p>The attributes <code>height</code> no longer exist, so those lines throw errors.</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.area()                             # \u2705 Still works\n    perimeter = rect1.perimeter()                   # \u2705 Still works\n</code></pre> <p>Whereas, sticking to the abstraction layers (calling <code>area()</code> and <code>perimeter()</code> instead of directly accessing fields), your program still works after internal changes to the class design!</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teaching assistant!)</p> <ol> <li>What is the difference between accessing an attribute directly vs using a method?  Why might direct access lead to problems in larger programs?</li> <li>Consider the principle *\u201cTell, Don\u2019t Ask.\u201d: Why might this principle lead to better object-oriented code? </li> <li>How does changing the internal implementation of a class (e.g., switching from height to area in <code>Rectangle</code>) illustrate the value of abstraction?</li> </ol> <p>Jump to exercise 02</p>"},{"location":"notes/03/composition/","title":"Unit 03: Composition","text":"<p>In Object-Oriented Programming (OOP), composition is a another key design principle where we objects constructed from other objects. </p>"},{"location":"notes/03/composition/#car","title":"Car","text":"<p>To illustrate the concept of composition we will build on with the car example from unit 02.</p>"},{"location":"notes/03/composition/#separate-class-for-engine-and-brake","title":"Separate class for engine and brake","text":"<p>As you all may know, each car has a engine system and has a brake system. Therefore, we can model these systems separately creating a class for each.</p> EngineBrake <p>The <code>Engine</code> class is a simple model of an engine that can be turned on/off and can calculate its acceleration based on how much you press the pedal.</p> <pre><code>class Engine:\n\n    def __init__(self, max_acceleration: float) -&gt; None:\n        self.max_acceleration: float = max_acceleration\n        self.is_on: bool = False\n\n    def start(self) -&gt; None:\n        self.is_on = True\n\n    def stop(self) -&gt; None: \n        self.is_on = False\n\n    def is_running(self) -&gt; bool:\n        return self.is_on\n\n    def apply(self, paddle_ratio) -&gt; float:\n        if paddle_ratio &lt; 0 or  paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 to 1\")\n\n        if not self.is_running() and paddle_ratio &gt; 0:\n            raise Exception(\"The engine cannot accelerate when it is stopped\")\n\n        return self.max_acceleration * paddle_ratio\n</code></pre> <p>The <code>Brake</code> class simulates a brake that gets worn the more you use it, and calculates braking force accordingly.</p> <pre><code>class Brake:\n\n    def __init__(self, max_deceleration: float)\n        self.max_deceleration: float = max_deceleration\n        self.wear: float = 0                   \n\n    def apply(paddle_ratio: float) -&gt; float:\n        if paddle_ratio &lt; 0 or  paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 to 1\")\n\n        self.wear += 0.00001 * paddle_ratio    \n        return self.max_deceleration * paddle_ratio * max(self.wear, 0.1) * -1 # return a negative acceleration\n</code></pre>"},{"location":"notes/03/composition/#composition-of-engine-and-brake-for-the-car","title":"Composition of engine and brake for the Car","text":"<p>Using the brake and the engine to build our new <code>Car</code> class, we achieved the composition of classes as follows:</p> <pre><code>class Car:\n    def __init__(self, start_pos: float, engine: Engine, brake: Brake) -&gt; None:\n        self.position: float = start_pos\n        self.speed = 0\n\n        self.engine: Engine = engine\n        self.brake: Brake = brake\n\n    def start(self) -&gt; None:\n        self.engine.start()\n\n    def stop(self) -&gt; None:\n        self.engine.stop()\n\n    def _accelerate(self, acceleration: float) -&gt; None: # function name starting with an _method_name in python, typically denotes an internal (private) method that should not be called by outsiders \n        # Same formula you saw in exercise 02\n        dt = 1.0\n        v0 = self.speed\n        v1 = max(v0 + acceleration * dt, 0)\n        dx = 0.5 * (v0 + v1) * dt\n\n        self.speed = v1 \n        self.position += dx\n\n    def drive(self, paddle_ratio: float) -&gt; None:\n        acceleration = self.engine.apply(paddle_ratio)\n        self._accelerate(acceleration)\n\n    def brake(self, paddle_ratio: float) -&gt; None:\n        deceleration = self.brake.apply(paddle_ratio) # this is negative\n        self._accelerate(deceleration)\n</code></pre>"},{"location":"notes/03/composition/#class-diagram","title":"Class Diagram","text":"<p>The class diagram for the <code>Car</code> class is as shown </p> <p>The filled diamond arrow represent the has-a (compositional) relationship .</p>"},{"location":"notes/03/composition/#dangers-of-composition-references-aliasing","title":"Dangers of Composition: References / Aliasing","text":"<p>An possible danger of composition a is consequence of objects in python being reference type.  </p> <p>Consider the following example:</p> ExampleAnswer: Part 1Answer: Part 2 <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <p>Before clicking on the answer, can you guess what will happen and why it happens? </p> <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <p>The above example, we only create one engine object which both cars will be using. </p> <p>In other words, both the cars are sharing the one engine.</p> <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <p>Hence, in <code>line 14</code> when <code>car1</code> stopped its engine, <code>car2</code> engine is also stopped since is sharing the same engine object as <code>car1</code> resulting the error <code>The engine cannot accelerate when it is stopped</code> will appear when we run <code>line 15</code>.</p> <p>Key Takeaway</p> <p>The key takeaway here is that when we are dealing and passing object around, you need to be aware that you are NOT passing copies (unlike with primitive datatype like int/float/str) but the actual object itself. </p> <p>Jump to exercise 03</p>"}]}