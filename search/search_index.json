{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PY2 OOP","text":"<p>Welcome to the world of Objects!</p> <p>Congratulations on making it this far. With you knowledge gained from all the 186 exercises, you're ready to explore a new programming paradigm: Object-Oriented Programming!</p> <p>Unlike the procedural approach to programming, whereby we create procedure (functions) to do repetitive task, in OOP you will be learning how to model objects (possibly real world object) using code!</p> <p>This website will host the materials: notes, exercise and project for the PY2 OOP curriculum</p>"},{"location":"exercises/01/ex01/","title":"Exercise 1: Circles","text":"<p>In this exercise, you\u2019ll create your first class in Python!</p>"},{"location":"exercises/01/ex01/#brief","title":"Brief","text":"<p>Suppose you have three circles with radii of 5, 10, and 20, respectively. Model these circles as objects so that you can easily determine each circle\u2019s radius, diameter, area, and perimeter.</p> <p></p>"},{"location":"exercises/01/ex01/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub. </p>"},{"location":"exercises/01/ex01/#task-1-create-a-class-diagram","title":"Task 1: Create a Class Diagram","text":"<p>Before you start coding, open the <code>classes.drawio</code> file at draw.io or install the \u2018Draw.io Integration\u2019 extension for VS Code. Complete the class diagram by specifying the attributes and methods you plan to implement.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 3.</p>"},{"location":"exercises/01/ex01/#task-2-implement-the-class","title":"Task 2: Implement the Class","text":"<p>Using your class diagram as a guide, implement the <code>Circle</code> class in Python.</p>"},{"location":"exercises/01/ex01/#task-3-implement-the-__str__-method","title":"Task 3: Implement the <code>__str__</code> Method","text":"<p>Try printing an instance of your <code>Circle</code> object. You\u2019ll likely see something like:</p> <pre><code>&lt;__main__.Circle object at 0x000001E558684410&gt;\n</code></pre> <p>This default output isn\u2019t informative, as it only displays the object\u2019s memory address.</p> <p>Fortunately, Python provides a special method called <code>__str__</code>, which lets you customize how your object is displayed when printed.</p> <p>Your task: Modify your <code>Circle</code> class by implementing the <code>__str__</code> method so that printing a circle displays something like:</p> <pre><code>Circle with radius 5.00; diameter 10.00; area 78.54 \n</code></pre>"},{"location":"exercises/02/ex02/","title":"Exercise 2: Car","text":"<p>In this exercise, you will refactor poorly written code to better follow the Information Hiding and Tell Don\u2019t Ask principles. The scenario involves solving a simple physics problem.</p>"},{"location":"exercises/02/ex02/#brief","title":"Brief","text":"<p>Suppose a car starts from rest at position 0 meters with an initial speed of 0 m/s. John gets into the car and presses the gas pedal, causing the car to accelerate at a constant rate of 2 m/s\u00b2 for 5 seconds. From t=6 to t=8s, he maintains the current speed, applying neither acceleration nor deceleration (assume that there is no friction or air resistance). Finally, at 9 seconds, he steps on the brakes that has a breaking power of 8 m/s\u00b2.</p> <p>Determine the the nearest second at which the car comes to a complete stop and tabulate the car\u2019s position and speed at each second from t = 0 to the moment it stops. </p> <p>Model your car object such that each action takes 1 unit of time.</p>"},{"location":"exercises/02/ex02/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub.</p>"},{"location":"exercises/02/ex02/#task-1-study-the-existing-code","title":"Task 1: Study the Existing Code","text":"<p>Study the provided poorly written OOP code to understand how it works and identify areas for improvement.</p>"},{"location":"exercises/02/ex02/#task-2-design-your-class","title":"Task 2: Design Your Class","text":"<p>Open the <code>Circle.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code. Create a class diagram for the <code>Car</code> class, specifying its attributes and methods. Focus on ensuring your design follows the principles of Information Hiding and Tell Don\u2019t Ask.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 3.</p>"},{"location":"exercises/02/ex02/#task-3-implementation","title":"Task 3: Implementation","text":"<p>Refactor and rewrite the program using your class diagram.  Implement the new <code>Car</code> class so that it adheres to the Information Hiding and Tell Don\u2019t Ask principles.</p>"},{"location":"exercises/03/ex03/","title":"Exercise 3: Circle with Coordinates","text":"<p>This exercise will help you understand composition in object-oriented programming by modeling geometric objects in a 2D Cartesian plane. Specifically, we will be focusing on the <code>Circle</code> class from exercise 01. </p> <p>You will also explore how Python handles primitive and reference types and some things to take note of.</p>"},{"location":"exercises/03/ex03/#brief","title":"Brief","text":"<p>Previously, you learned how to model a simple shape like a <code>Circle</code> using classes. Now, you will extend this circle and place it in 2D Cartesian (x-y) plane. This means each shape must also keep track of its position in the x-y plane. </p> <p> Above is an image of a circle with the circle point (0,0) and a radius of 10. </p>"},{"location":"exercises/03/ex03/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/03/ex03/#task-1-primitive-vs-reference-types","title":"Task 1: Primitive vs Reference Types","text":"<p>Open the file <code>task1.py</code> and write a short code example that demonstrates how Python handles:</p> <ul> <li>Primitive types (e.g., <code>int</code>, <code>float</code>)</li> <li>Reference types (e.g., <code>list</code>, <code>dict</code>, or your own class)</li> </ul> <p>Implement functions that show how assignment and modification affect the original variables for both primitive and reference types.</p>"},{"location":"exercises/03/ex03/#task-2-point-class","title":"Task 2: <code>Point</code> Class","text":"<p>Rather than keeping track of x,y coordinate individually with our shapes using attribute for each shape, we will create a dedicated <code>Point</code> class that encapsulate the coordinate and the related logic for us.</p>"},{"location":"exercises/03/ex03/#design","title":"Design","text":"<p>Thus, we will begin by creating a <code>Point</code> class with these specifications:</p> <p>Attributes:</p> <ul> <li><code>x</code> (float): The x-coordinate.</li> <li><code>y</code> (float): The y-coordinate.</li> </ul> <p>Methods:</p> <ul> <li><code>distance_to(other)</code>: Returns the Euclidean distance between this point and another <code>Point</code> object.</li> <li><code>__str__</code>: Returns a string representation in the format <code>(x, y)</code>.</li> </ul>"},{"location":"exercises/03/ex03/#__eq__-method","title":"<code>__eq__</code> method","text":"<p>Before you continue, explore the following code:</p> <pre><code>p1 = Point(0,0)\np2 = Point(0,0)\n\nprint(p1 == p2)\n</code></pre> <p>Even though both p1 and p2 at at (0,0), the output of this code will be false! </p> <p>By default if you do not implement the <code>__eq__</code> method in python, python will compare whether the object are the same if they have same reference (location in memory). Since, p1 &amp; p2 has different reference (as they are 2 separate object located in different area of the memory) it return false. </p> <p>While, something like <pre><code>p1 = Point(0,0)\np2 = p1\n\nprint(p1 == p2)\n</code></pre> will return true.</p> <p>Your task: Implement the <code>__eq__</code> method such that we can compare the <code>Point</code> objects using the == operator. </p>"},{"location":"exercises/03/ex03/#task-3-design-the-circle-class-using-composition","title":"Task 3: Design the <code>Circle</code> Class Using Composition","text":"<p>Redesign your <code>Circle</code> class from Exercise 1 to utilize composition by including a <code>Point</code> object as its center. </p> <p>Implement another a method such we are able to find the distance between 2 circle. Raise a ValueError if the object is not a circle (hint: use <code>isinstance(...) function</code>)</p> <p></p> <p>Note: If the circle is overlapping you should return zero. </p>"},{"location":"exercises/04/ex04/","title":"Exercise 4: Currency Converter","text":""},{"location":"exercises/04/ex04/#brief","title":"Brief","text":"<p>Previously, you learned how to build simple classes with instance attributes and methods. Now, you will work on a class that makes use of class-level state a concept where the same value is shared across all instances of a class.</p> <p>This exercise will help you understand how to use class methods and class variables in object-oriented programming. You'll model a simple currency converter that converts SGD (Singapore Dollar) to other currencies based on a shared exchange rate.</p> <p>You will explore how a single shared rate can be updated for all instances, and how to use <code>@classmethod</code> to manage this logic.</p>"},{"location":"exercises/04/ex04/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/04/ex04/#task-1-class-variables-and-instance-methods","title":"Task 1: Class Variables and Instance Methods","text":""},{"location":"exercises/04/ex04/#your-task","title":"Your Task:","text":"<p>Open the file <code>task1.py</code>. Complete the following:</p> <ol> <li>Create a class called <code>CurrencyConverter</code>.</li> <li>Add the following class variables for exchange rates:<ul> <li><code>sgd_to_usd</code> (e.g. <code>0.74</code>)</li> <li><code>sgd_to_eur</code> (e.g. <code>0.68</code>)</li> <li><code>sgd_to_jpy</code> (e.g. <code>100.2</code>)</li> </ul> </li> <li>In the constructor (<code>__init__</code>), accept an amount in SGD and store it as an instance variable <code>sgd</code>.</li> <li> <p>Write instance methods that convert to each currency:</p> <ul> <li><code>to_usd()</code></li> <li><code>to_eur()</code></li> <li><code>to_jpy()</code></li> </ul> </li> </ol>"},{"location":"exercises/04/ex04/#example","title":"Example:","text":"<pre><code>c = CurrencyConverter(100)\nprint(c.to_usd())  # 74.0\nprint(c.to_eur())  # 68.0\nprint(c.to_jpy())  # 10020.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-2-class-methods-for-updating-rates","title":"Task 2: Class Methods for Updating Rates","text":"<p>Sometimes, currency rates change. Instead of updating the rate for each instance, we\u2019ll update the class variable using <code>@classmethod</code>.</p>"},{"location":"exercises/04/ex04/#your-task_1","title":"Your Task:","text":"<p>Add the following class methods:</p> <ul> <li><code>set_usd_rate(cls, new_rate)</code></li> <li><code>set_eur_rate(cls, new_rate)</code></li> <li><code>set_jpy_rate(cls, new_rate)</code></li> </ul> <p>Each method should update the corresponding class variable.</p>"},{"location":"exercises/04/ex04/#example_1","title":"Example:","text":"<pre><code>c1 = CurrencyConverter(100)\nprint(c1.to_eur())  # 68.0\nCurrencyConverter.set_eur_rate(0.75)\nprint(c1.to_eur())  # 75.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-3-alternative-constructor","title":"Task 3: Alternative Constructor","text":"<p>Sometimes, we want to create a <code>CurrencyConverter</code> instance from EUR, and have it compute the SGD amount automatically based on the current exchange rate.</p>"},{"location":"exercises/04/ex04/#your-task_2","title":"Your Task:","text":"<p>Add a class method <code>from_eur(cls, eur_amount)</code> that:</p> <ol> <li>Converts <code>eur_amount</code> to SGD using the current <code>sgd_to_eur</code> rate.</li> <li>Returns a new <code>CurrencyConverter</code> object with the computed SGD amount.</li> </ol>"},{"location":"exercises/04/ex04/#example_2","title":"Example:","text":"<pre><code>CurrencyConverter.set_eur_rate(0.75)\nc2 = CurrencyConverter.from_eur(75)\nprint(c2.sgd)       # 100.0\nprint(c2.to_eur())  # 75.0\n</code></pre>"},{"location":"notes/01/basics/","title":"Unit 01: Basics","text":""},{"location":"notes/01/basics/#the-3-rectangles-problem","title":"The 3 Rectangles Problem","text":"<p>Let\u2019s dive right in with an example. Suppose we have three rectangles as shown in the figure below. Our task is to find the area and perimeter of each rectangle.</p> <p></p>"},{"location":"notes/01/basics/#the-naive-approach","title":"The Naive Approach","text":"<p>A straightforward approach to this problem is to represent each rectangle as a tuple containing its base and height, and store these tuples in a list. To compute the area and perimeter of each rectangle, we extract the base and height from each tuple and apply the following formulas:</p> <ul> <li>Area = base \u00d7 height</li> <li>Perimeter = 2 \u00d7 (base + height)</li> </ul> <pre><code>rectangles = [(1, 2), (3, 4), (5, 6)]\n\nrect: tuple\nfor i, rect in enumerate(rectangles):\n    base, height = rect\n    area = base * height\n    perimeter = 2 * (base + height)\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre>"},{"location":"notes/01/basics/#the-oop-approach","title":"The OOP Approach","text":"<p>Now, let's see how using objects can simplify this problem!</p> Step 1: CreateStep 2: Ask <p>Instead of using tuples, we create instances of a <code>Rectangle</code> class.</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n</code></pre> <p>Rather than manually calculating the area and perimeter, we simply ask each object for its area and perimeter!</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n\nrect: Rectangle\nfor i, rect in enumerate(rectangles):\n    area = rect.area()\n    perimeter = rect.perimeter()\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre> <p>Key Takeaway</p> <p>Notice the difference? In the OOP approach, we don\u2019t need to know the formulas for area and perimeter - the logic for those are encapsulated within the object. This demonstrates two key principles of OOP: abstraction and encapsulation. </p> <p>Abstraction means hiding complex implementation details and exposing only what\u2019s essential to the user. This makes code easier to read, maintain, and reuse, while reducing complexity as programs grow. Just as high-level languages abstract away machine code, OOP lets you focus on what objects do, not how they do it. This makes programming simpler and more manageable as you begin to write more complex code and programs.</p> <p>In fact, you\u2019ve already been using objects all along. In Python, almost everything is an object. Perhaps the object you have used the most and is familiar to you are strings; strings are objects, and you likely have used methods like isalpha() and isdigit().</p> <p>Have you ever wondered how those methods are actually implemented under the hood? did you actually need to know how it works under the hood?</p>"},{"location":"notes/01/basics/#creating-the-rectangle-class","title":"Creating the <code>Rectangle</code> Class","text":"<p>So far, we\u2019ve only discussed how to use a <code>Rectangle</code> class, but how do we actually create one?</p> Step 1: DeclarationStep 2: Attributes and ConstructorStep 3: Methods <p>We start by declaring the class we want to create.</p> <pre><code>class Rectangle:\n    ...\n</code></pre> <p>Next, we define a special method called <code>__init__</code>, known as the constructor. The constructor is automatically called when a new instance of the class is created. Here, we set up the initial state of the object by assigning values to its attributes.</p> <p>Attributes are variables that belong to an object and describe its properties. For a rectangle, we need its base and height, so we give it two attributes: <code>base</code> and <code>height</code>.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):   # self refers to the instance being created\n        self.base = base                # Save the base value in the instance\n        self.height = height\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5) # Creating a rectangle instance: this internally calls Rectangle.__init__(10, 5)\n</code></pre> <p>Class vs Instance</p> <p>Declaring a class defines the blueprint for creating objects. An instance is an actual object created from that blueprint.</p> <p>Finally, we implement the methods that provide the desired behaviors for our object.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return 2 * (self.base + self.height)\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5)\n    rect1.area()                # returns 50\n    rect1.perimeter()           # returns 30\n</code></pre>"},{"location":"notes/01/basics/#class-diagram","title":"Class Diagram","text":"<p>To help visualize classes, we often use a class diagram. A class diagram provides a concise overview of all the attributes and methods a class contains.</p> <p></p> <p>In the diagram above is the class diagram for <code>Rectangle</code>. It typically consists of 2 rows where:</p> <ul> <li>The first row lists the attributes and their data types.</li> <li>The second row lists the method signatures and their return types.</li> </ul> <p>Discussion</p> <p>Discussion questions (please discuss these with your teacher!):</p> <ol> <li> <p>What is the difference between a class and an instance of a class?</p> </li> <li> <p>What does it mean to say that a class abstracts something, and why is abstraction useful in programming?</p> </li> <li> <p>What does the <code>self</code> keyword refer to?</p> </li> </ol> <p>Jump to exercise 01</p>"},{"location":"notes/02/information-hiding/","title":"Unit 02: Information Hiding","text":""},{"location":"notes/02/information-hiding/#abstraction-layer","title":"Abstraction Layer","text":"<p>Building on Unit 1, another fundamental aspect of good object-oriented design is the concept of information hiding and maintaining the abstraction layer.</p> <p>In Python, there are fewer restrictions are enforced compared to other languages like OOP focused language like Java. This means it's easier to accidentally (or even intentionally) bypass the abstraction layer when working with OOP code. Hence, it's your responsibility to respect and protect this boundary.</p> <p>Violating the abstraction layer often leads to a phenomenon known as \"spaghetti code\" - code that is so tangled and interdependent that even small changes can break your entire program.</p> <p></p>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-car-correctness","title":"Breaking the Abstraction Layer: Car (Correctness)","text":"<p>To understand what it means to break an abstraction layer, let's consider the following <code>Car</code> class:</p> <pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self.position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self.position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self.position += distance\n</code></pre> <p>This class model a simple car driving along a 1D road. You move the car by calling the <code>drive()</code> method, which updates its position by a given distance.</p> \u2705 Correct Usage (Abstraction Maintained)\u274c Broken Abstraction Layer <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car1.drive(10)\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This is the proper way to use the <code>Car</code> class. We instruct the car to drive, and let the internal logic handles the position update to the car instance.</p> <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car.position = car.position + 10\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Instead of tell the car to drive like before, you\u2019re essentially now stepping out of the car and pushing the car manually</p> <p>Imagine trying to drive a car, only for someone else to randomly push it from the outside! Likewise, directly changing attributes can lead to unpredictable or buggy behavior.</p> <p>Tell, Don\u2019t Ask</p> <p>This example also breaks the \"Tell, Don\u2019t Ask\" principle, another core OOP principle which state that we should tell object to what to do instead of asking for information and doing it ourself. </p> <ul> <li>\u2705 Correct: <code>car.drive(10)</code> \u2192 You instruct the car itself to move.</li> <li>\u274c Incorrect: <code>car.position = car.position + 10</code> \u2192 You ask for the car\u2019s position and change it manually.</li> </ul>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-rectangle-maintainability","title":"Breaking the Abstraction Layer: Rectangle (Maintainability)","text":"<p>Preserving the abstraction layer also makes your code easier to maintain and refactor if you like to make changes to it in the future. Let\u2019s revisit the <code>Rectangle</code> class from Unit 01:</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>Suppose you initially calculated area and perimeter by accessing the class fields directly:</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.base * rect1.height                # 50\n    perimeter = 2 * (rect1.base + rect1.height)     # 30\n</code></pre> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.area()                             # 50\n    perimeter = rect1.perimeter()                   # 30\n</code></pre> <p>Later, you might decide to represent a rectangle using its <code>base</code> and <code>area</code> instead of <code>height</code>. After all, only two of the three (base, height, area) are needed to compute the third, thus this redesign is a valid one.</p> New ClassOriginal Class <pre><code>class Rectangle:\n    def __init__(self, base, area):  \n        self.base = base               \n        self.area = area\n\n    def area(self):\n        return self.area\n\n    def perimeter(self):\n        return self.base * 2 + (self.area / self.base) * 2\n</code></pre> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>If you previously accessed fields directly, your main program will break after this internal change:</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.base * rect1.height                # \u274c Broken\n    perimeter = 2 * (rect1.base + rect1.height)     # \u274c Broken\n</code></pre> <p>The <code>height</code> attribute no longer exists, so these lines now cause errors.</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.area()                             # \u2705 Still works\n    perimeter = rect1.perimeter()                   # \u2705 Still works\n</code></pre> <p>By using the class\u2019s methods (the abstraction layer), your code continues to work even after the internal representation changes!</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teaching assistant!)</p> <ol> <li>What is the difference between accessing an attribute directly vs using a method? Why might direct access lead to problems in larger programs?</li> <li>Consider the principle \u201cTell, Don\u2019t Ask.\u201d Why might this lead to better object-oriented code?</li> <li>How does changing the internal implementation of a class (e.g., switching from height to area in <code>Rectangle</code>) illustrate the value of abstraction?</li> </ol> <p>Jump to exercise 02</p>"},{"location":"notes/03/composition/","title":"Unit 03: Composition","text":"<p>In Object-Oriented Programming (OOP), composition is another fundamental design principle: objects can be constructed from other objects. This allows you to build complex systems flexibly, by combining simpler, well-defined components.</p>"},{"location":"notes/03/composition/#car-example","title":"Car Example","text":"<p>Let\u2019s build on our car example from Unit 02 to illustrate composition.</p>"},{"location":"notes/03/composition/#creating-separate-classes-for-engine-and-brake","title":"Creating Separate Classes for Engine and Brake","text":"<p>A real car has an engine system and has a brake system. Instead of bundling these directly into the <code>Car</code>, we can create distinct classes for each. This enables modular design and reuse.</p> EngineBrake <p>The <code>Engine</code> class models an engine that can be started or stopped, and calculates acceleration based on how much you press the pedal.</p> <pre><code>class Engine:\n\n    def __init__(self, max_acceleration: float) -&gt; None:\n        self.max_acceleration: float = max_acceleration\n        self.is_on: bool = False\n\n    def start(self) -&gt; None:\n        self.is_on = True\n\n    def stop(self) -&gt; None: \n        self.is_on = False\n\n    def is_running(self) -&gt; bool:\n        return self.is_on\n\n    def apply(self, paddle_ratio) -&gt; float:\n        if paddle_ratio  1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        if not self.is_running() and paddle_ratio &gt; 0:\n            raise Exception(\"The engine cannot accelerate when it is stopped.\")\n\n        return self.max_acceleration * paddle_ratio\n</code></pre> <p>The <code>Brake</code> class simulates how a brake gets worn down with use and calculates braking force accordingly.</p> <pre><code>class Brake:\n\n    def __init__(self, max_deceleration: float):\n        self.max_deceleration: float = max_deceleration\n        self.wear: float = 0                   \n\n    def apply(self, paddle_ratio: float) -&gt; float:\n        if paddle_ratio  1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        self.wear += 0.00001 * paddle_ratio    \n        # Braking effect reduces as wear increases, and is always negative (slows the car)\n        return self.max_deceleration * paddle_ratio * max(self.wear, 0.1) * -1\n</code></pre>"},{"location":"notes/03/composition/#composing-engine-and-brake-in-car","title":"Composing Engine and Brake in Car","text":"<p>By using the <code>Engine</code> and <code>Brake</code> objects inside the new <code>Car</code> class, we demonstrate composition:</p> <pre><code>class Car:\n    def __init__(self, start_pos: float, engine: Engine, brake: Brake) -&gt; None:\n        self.position: float = start_pos\n        self.speed = 0\n\n        self.engine: Engine = engine\n        self.brake: Brake = brake\n\n    def start(self) -&gt; None:\n        self.engine.start()\n\n    def stop(self) -&gt; None:\n        self.engine.stop()\n\n    def _accelerate(self, acceleration: float) -&gt; None:\n        # Internal method: should not be called directly from outside this class\n        dt = 1.0\n        v0 = self.speed\n        v1 = max(v0 + acceleration * dt, 0)\n        dx = 0.5 * (v0 + v1) * dt\n\n        self.speed = v1 \n        self.position += dx\n\n    def drive(self, paddle_ratio: float) -&gt; None:\n        acceleration = self.engine.apply(paddle_ratio)\n        self._accelerate(acceleration)\n\n    def brake(self, paddle_ratio: float) -&gt; None:\n        deceleration = self.brake.apply(paddle_ratio) # this is negative\n        self._accelerate(deceleration)\n</code></pre>"},{"location":"notes/03/composition/#class-diagram","title":"Class Diagram","text":"<p>The class diagram for the <code>Car</code> class looks like this:</p> <p></p> <p>The diamond-shaped arrows represents a 'has-a' relationship between objects </p>"},{"location":"notes/03/composition/#dangers-of-composition-references-aliasing","title":"Dangers of Composition: References / Aliasing","text":"<p>A potential hazard of composition in Python is object aliasing-because objects are reference types.</p>"},{"location":"notes/03/composition/#example","title":"Example","text":"ExampleAnswer: Part 1Answer: Part 2 <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <p>Study the above code. What do you expect to happen here and why? (hint: a line will throw an error) </p> <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    ...\n</code></pre> <p>The above example, we only created one engine object which both object are referencing. In other words, both cars are sharing one engine.</p> <pre><code>def main():\n    ...\n    car1.stop()          # Stops the engine for BOTH car1 and car2\n    car2.drive(0.3)      # This will raise an Exception: \"The engine cannot accelerate when it is stopped\"\n    ...\n</code></pre> <p>Thus, when <code>car1.stop()</code> is called, it shuts down the shared engine. So, even though you're calling <code>car2.drive(0.3)</code> next, the engine is already stopped-triggering an exception.</p> <p>Unintended side effects</p> <p>When you pass objects in Python, you are passing references to the actual objects and not creating copies (unlike with primitive types like <code>int</code>, <code>float</code>, or <code>str</code>). Always be mindful of this, especially when composing objects as sharing objects (aliasing) can have unintended side effects if not managed carefully!</p> <p>Jump to exercise 03</p>"},{"location":"notes/04/class-field-method/","title":"Unit 04: Class Fields and Methods","text":"<p>Using the <code>Rectangle</code> class from Unit 01, this unit will introduce you to the difference between instance and class variables, as well as instance and class methods.</p>"},{"location":"notes/04/class-field-method/#variables","title":"Variables","text":""},{"location":"notes/04/class-field-method/#instance-variables","title":"Instance Variables","text":"<p>As a recap instance variables are used to store data unique to each object. They are defined with <code>self</code> inside the <code>__init__</code> constructor and belong to each specific instance of a class.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self.base = base         # instance variable\n        self.height = height     # instance variable\n\n    ...\n</code></pre> <p>Every <code>Rectangle</code> object instance has its own <code>base</code> and <code>height</code>, so changes to one object\u2019s instance variables won\u2019t affect others.</p>"},{"location":"notes/04/class-field-method/#class-variables","title":"Class Variables","text":"<p>In contrast, class variables are shared among all instances of a class. They are typically used for properties that should be consistent for every object, or to keep track of class-level information.</p> <p>For example, all rectangles have four sides, and you may want to count how many rectangles have been created:</p> <pre><code>class Rectangle:\n    SIDES = 4           # class variable (constant)\n    count = 0           # class variable (for tracking)\n\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n        Rectangle.count += 1    # update class variable\n\n    ...\n</code></pre> <p>No matter how many <code>Rectangle</code> objects you create, both <code>SIDES</code> and <code>count</code> are shared and accessible from every instance and through the class itself.</p>"},{"location":"notes/04/class-field-method/#methods","title":"Methods","text":""},{"location":"notes/04/class-field-method/#instance-methods","title":"Instance Methods","text":"<p>Like instance variables, instance methods operate on individual objects and can access or modify instance variables. In Python, they always take <code>self</code> as their first parameter.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):               # instance method\n        return self.base * self.height\n\n    ...\n</code></pre>"},{"location":"notes/04/class-field-method/#class-methods","title":"Class Methods","text":"<p>Similarly, class methods are used for operations that affect the class as a whole, not specific instances. They are defined with the <code>@classmethod</code> decorator and take <code>cls</code> as their first parameter.</p> <pre><code>class Rectangle:\n    count = 0\n\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n        Rectangle.count += 1\n\n    @classmethod\n    def how_many(cls):           # class method\n        return cls.count         # cls here is Rectangle\n</code></pre> <p>Limited Access</p> <p>Class methods cannot access instance variables (since they don\u2019t have access to <code>self</code>), but can access class variables and other class methods.</p>"},{"location":"notes/04/class-field-method/#summary","title":"Summary","text":"<p>Summary Table</p> Field/Method Type How to Define Belongs To First Parameter Can Access Use Case Instance variable <code>self.base</code> Instance - Instance Data unique to each object Instance method <code>def area(self):</code> Instance <code>self</code> Instance Behavior based on instance attributes Class variable <code>count = 0</code> Class - Class Data shared by all instances Class method <code>@classmethod</code> Class <code>cls</code> Class Behavior related to the class itself <p>Jump to exercise 04</p>"},{"location":"notes/05/subclasses/","title":"Unit 05: Inheritance and Subclasses","text":"<p>In Unit 03, we looked at how we can build complex classes using composition \u2014 that is, combining smaller classes together to model a has-a relationship. Now, we\u2019ll look at how to model an is-a relationship between classes using inheritance!</p>"},{"location":"notes/05/subclasses/#square-rectangle","title":"Square &amp; Rectangle","text":""},{"location":"notes/05/subclasses/#creating-a-square","title":"Creating a Square","text":"<p>Suppose we want to create a new class called Square. We might start off implementing it like this:</p> <pre><code>class Square:\n    def __init__(self, length):\n        self._base = length\n        self._height = length\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <p>Looks familiar, right? It\u2019s basically the exact same code as our Rectangle class from Unit 01. That\u2019s because a square is really just a special case of a rectangle \u2014 it\u2019s a rectangle where the base and height are equal. So we can say that a Square is a Rectangle \u2014 it\u2019s a subset of rectangles.</p> <p>In other words, a Square is-a Rectangle.</p> <p></p>"},{"location":"notes/05/subclasses/#inheriting-a-rectangle","title":"Inheriting a Rectangle","text":"<p>Instead of rewriting all of Rectangle\u2019s code in Square, we can use inheritance to reuse it:</p> New SquareRectangle <pre><code>class Square(Rectangle):                      # This tells Python that Square inherits from Rectangle\n    def __init__(self, length):\n        super().__init__(length, length)      # super() means \"call the parent class\", so this runs Rectangle's __init__\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Just like that, we're done! Square now has access to all the methods in Rectangle, automatically.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def __str__(self):\n        return f\"Rectangle with {self.get_base()} base and {self.get_height()} height\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <p>Now we can say that Square is a subclass of Rectangle \u2014 or using the parent-child terminology, Square is the child and Rectangle is the parent.</p> <p>The class diagram for this looks like:</p> <p></p>"},{"location":"notes/05/subclasses/#method-overriding","title":"Method Overriding","text":"<p>You might\u2019ve noticed that we defined a str method again inside our Square class. That\u2019s called method overriding.</p> <pre><code>class Square(Rectangle):                    \n    def __init__(self, length):\n        super().__init__(length, length)    \n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>We are replacing the str method from Rectangle with a new version specific to Square.</p> Without str methodWith str method <p>If we didn\u2019t define the str method in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n</code></pre> <p>Then this code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Would give us:</p> <pre><code>Rectangle with 5 base and 5 height\n</code></pre> <p>This happens because Square didn't define its own str, so it just uses the one it inherited from Rectangle.</p> <p>But if we do define str in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Then the same code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Will now give us:</p> <pre><code>Square with 5 length\n</code></pre> <p>Here, we\u2019ve overridden the str method from Rectangle with a new one tailored for Square.</p> <p>Method Resolution Order (MRO)</p> <p>When you call a method on an object, Python doesn\u2019t just guess \u2014 it follows a rule called the Method Resolution Order (MRO).</p> <pre><code>Python first checks the child class (like Square). If the method exists there, it uses it. If not, it \"moves up\" to the parent (like Rectangle) and checks there. If that parent had its own parent, Python would keep going up the chain.\n\nSo in our case, Python sees that Square has a __str__ method, and uses it. If it didn\u2019t, it would use the one from Rectangle.\n\nNote: Unlike other languages, python doesn\u2019t care how many arguments the method takes \u2014 it only checks the method name. If a child and parent both have a method with the same name, the child\u2019s version always takes priority.\n</code></pre>"},{"location":"notes/05/subclasses/#negative-example-when-not-to-use-inheritance","title":"Negative example: When NOT to Use Inheritance","text":"<p>Inheritance tends to get overused. In practice, we seldom use inheritance. Let's look at some examples of how not to use inheritance, and why.</p> <p>You may come across examples online or in books that look like the following:</p> <p>class Point {   private double x;   private double y;     : }</p> <p>class Circle extends Point {   private double radius;     : }</p> <p>class Cylinder extends Circle {   private double height;     : } The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition.</p> <p>Circle implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); Cylinder would have the fields corresponding to a circle, which is its base and height. In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class.</p> <p>When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows:</p> <p>void foo(Circle c, Point p) {   if (c.contains(p)) {     // do something   } } Since Cylinder is a subtype of Point according to the implementation above, the code above should still work also if we replace Point with a Cylinder (according to the semantic of subtyping). But it gets weird -- what is the meaning of a Circle (in 2D) containing a Cylinder (in 3D)? We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of foo expects.</p> <p>The message here is this: Use composition to model a has-a relationship; inheritance for a is-a relationship. Make sure inheritance preserves the meaning of subtyping.</p> <p>Jump to exercise 05</p>"}]}