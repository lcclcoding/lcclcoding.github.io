{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#py2-oop","title":"PY2 OOP","text":"<p>Welcome to the world of Objects!</p> <p>Congratulations on making it this far. With you knowledge gained from all the 186 exercises, you're ready to explore a new programming paradigm: Object-Oriented Programming!</p> <p>Unlike the procedural approach to programming, whereby we create procedure (functions) to do repetitive task, in OOP you will be learning how to model objects (possibly real world object) using code!</p> <p>This website will host the materials: notes, exercise and project for the PY2 OOP curriculum</p>"},{"location":"exercises/01/ex01/","title":"01. Circles","text":""},{"location":"exercises/01/ex01/#exercise-1-circles","title":"Exercise 1: Circles","text":"<p>In this exercise, you\u2019ll create your first class in Python!</p>"},{"location":"exercises/01/ex01/#brief","title":"Brief","text":"<p>Suppose you have three circles with radii of 5, 10, and 20, respectively. Model these circles as objects so that you can easily determine each circle\u2019s radius, diameter, area, and perimeter.</p> <p></p>"},{"location":"exercises/01/ex01/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub.</p>"},{"location":"exercises/01/ex01/#task-1-create-a-class-diagram","title":"Task 1: Create a Class Diagram","text":"<p>Before you start coding, open the <code>classes.drawio</code> file at draw.io or install the \u2018Draw.io Integration\u2019 extension for VS Code. Complete the class diagram by specifying the attributes and methods you plan to implement.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before proceeding to task 2.</p>"},{"location":"exercises/01/ex01/#task-2-implement-the-class","title":"Task 2: Implement the Class","text":"<p>Using your class diagram as a guide, implement the <code>Circle</code> class in Python.</p>"},{"location":"exercises/01/ex01/#task-3-implement-the-__str__-method","title":"Task 3: Implement the <code>__str__</code> Method","text":"<p>Try printing an instance of your <code>Circle</code> object. You\u2019ll likely see something like:</p> <pre><code>&lt;__main__.Circle object at 0x000001E558684410&gt;\n</code></pre> <p>By default, python will display the object\u2019s memory address which isn't really useful to us. Fortunately, python provides a special method <code>__str__</code> that allow you to customize how your object is displayed when printed.</p> <p>Modify your <code>Circle</code> class by implementing the <code>__str__</code> method so that printing a circle displays useful information like:</p> <pre><code>Circle with radius 5.00; diameter 10.00; area 78.54 \n</code></pre>"},{"location":"exercises/02/ex02/","title":"02. Cars","text":""},{"location":"exercises/02/ex02/#exercise-2-car","title":"Exercise 2: Car","text":"<p>In this exercise, you will refactor poorly written code to better follow the Information Hiding and Tell Don\u2019t Ask principles. The scenario involves modelling a simple physics problem.</p>"},{"location":"exercises/02/ex02/#brief","title":"Brief","text":"<p>Suppose a car starts from rest at position 0 meters with an initial speed of 0 m/s. John gets into the car and presses the gas pedal, causing the car to accelerate at a constant rate of 2 m/s\u00b2 for 5 seconds. From t=6 to t=8s, he cruise at the current speed, applying neither acceleration nor deceleration (assume that there is no friction or air resistance). Finally, at 9 seconds, he steps on the brakes that has a breaking power of 8 m/s\u00b2.</p> <p>Determine the the nearest second at which the car comes to a complete stop and tabulate the car\u2019s position and speed at each second from t = 0 to the moment it stops.</p> <p>Model your car object such that each action takes 1 unit of time.</p>"},{"location":"exercises/02/ex02/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Begin by accepting the assignment from GitHub.</p>"},{"location":"exercises/02/ex02/#task-1-study-the-existing-code","title":"Task 1: Study the Existing Code","text":"<p>Study the provided poorly written OOP code to understand how it works.</p>"},{"location":"exercises/02/ex02/#task-2-design-your-class","title":"Task 2: Design Your Class","text":"<p>Open the <code>classes.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code.</p> <p>Create a class diagram for the <code>Car</code> class, specifying its attributes and methods. Ensure that your design follows the principles of Information Hiding and Tell Don\u2019t Ask.</p> <p>Verbs</p> <p>Take note of the used verbs in the brief. Those should tell you what methods you need to have in your <code>Car</code> class</p>"},{"location":"exercises/02/ex02/#task-3-implementation","title":"Task 3: Implementation","text":"<p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before starting on task 3.</p> <p>Refactor and rewrite the program using your class diagram.  Implement the new <code>Car</code> class so that it adheres to the Information Hiding and Tell Don\u2019t Ask principles.</p>"},{"location":"exercises/03/ex03/","title":"03. Circle with Coordinates","text":""},{"location":"exercises/03/ex03/#exercise-3-circle-with-coordinates","title":"Exercise 3: Circle with Coordinates","text":"<p>This exercise will help you understand composition in object-oriented programming by modeling geometric objects in a 2D Cartesian plane. Specifically, we will be focusing on the <code>Circle</code> class from exercise 01.</p> <p>You will also explore how Python handles primitive and reference types and some things to take note of.</p>"},{"location":"exercises/03/ex03/#brief","title":"Brief","text":"<p>Previously, you learned how to model a simple shape like a <code>Circle</code> using classes. Now, you will extend this circle and place it in 2D Cartesian (x-y) plane. This means each circle must also keep track of coordinates in the x-y plane.</p> <p> Above is an image of a circle with the circle point (0,0) and a radius of 10.</p>"},{"location":"exercises/03/ex03/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/03/ex03/#task-1-primitive-vs-reference-types","title":"Task 1: Primitive vs Reference Types","text":"<p>Open the file <code>task1.py</code> and write a short code example that demonstrates how Python handles:</p> <ul> <li>Primitive types (e.g., <code>int</code>, <code>float</code>)</li> <li>Reference types (e.g., <code>list</code>, <code>dict</code>, or your own class)</li> </ul> <p>Implement functions that show how assignment and modification affect the original variables for both primitive and reference types.</p>"},{"location":"exercises/03/ex03/#task-2-point-class","title":"Task 2: <code>Point</code> Class","text":"<p>Rather than keeping track of x,y coordinate individually with our shapes using attribute for each shape, we will create a dedicated <code>Point</code> class that encapsulate the coordinate and the related logic for us.</p>"},{"location":"exercises/03/ex03/#design","title":"Design","text":"<p>Start by creating a <code>Point</code> class with these specifications:</p> <p>Attributes:</p> <ul> <li><code>x</code> (float): The x-coordinate.</li> <li><code>y</code> (float): The y-coordinate.</li> </ul> <p>Methods:</p> <ul> <li><code>distance_to(other)</code>: Returns the Euclidean distance between this point and another <code>Point</code> object. Raise a TypeError if the object is not another <code>Point</code> object (hint: use the <code>isinstance(...)</code> function)</li> <li><code>__str__</code>: Returns a string representation in the format <code>(x, y)</code>.</li> </ul>"},{"location":"exercises/03/ex03/#__eq__-method","title":"<code>__eq__</code> method","text":""},{"location":"exercises/03/ex03/#study","title":"Study","text":"<p>Before you continue to task 3, let us explore the following code:</p> <pre><code>p1 = Point(0,0)\np2 = Point(0,0)\n\nprint(p1 == p2)\n</code></pre> <p>Even though both p1 and p2 at at (0,0), the output of this code will be false!</p> <p>By default if you do not implement the <code>__eq__</code> method in python, python will compare whether the object are the same if they have same reference (location in memory). Since, p1 and p2 has different reference (as they are 2 separate object located in different area of the computer memory) it return false.</p> <p>On the other hand, something like</p> <pre><code>p1 = Point(0,0)\np2 = p1\n\nprint(p1 == p2)\n</code></pre> <p>will return true.</p>"},{"location":"exercises/03/ex03/#your-task","title":"Your task","text":"<p>Research on the <code>__eq__</code> method and implement it such that we can compare different <code>Point</code> objects using the == operator. Raise a TypeError if the object is not a point</p>"},{"location":"exercises/03/ex03/#task-3-design-the-circle-class-using-composition","title":"Task 3: Design the <code>Circle</code> Class Using Composition","text":"<p>Redesign your <code>Circle</code> class from Exercise 1 to utilize composition by including a <code>Point</code> object as its center. Implement another a method such we are able to find the distance between 2 circle. Raise a TypeError if the object is not a circle</p> <p></p> <p>Note: If the circle is overlapping you should return zero.</p>"},{"location":"exercises/04/ex04/","title":"04. Currency Converter","text":""},{"location":"exercises/04/ex04/#exercise-4-currency-converter","title":"Exercise 4: Currency Converter","text":"<p>This exercise will help you understand how to use class methods and class variables.</p>"},{"location":"exercises/04/ex04/#brief","title":"Brief","text":"<p>Previously, you learned how to build simple classes with instance attributes and methods. Now, you will work on a class that makes use of class-level state a concept where the same value is shared across all instances of a class. You'll model a simple currency converter that converts SGD (Singapore Dollar) to other currencies based on a shared exchange rate.</p> <p>You will explore how a single shared rate can be updated for all instances, and how to use <code>@classmethod</code> to manage this logic.</p>"},{"location":"exercises/04/ex04/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/04/ex04/#task-1-class-variables-and-instance-methods","title":"Task 1: Class Variables and Instance Methods","text":"<p>Open the file <code>task1.py</code>. Complete the following:</p> <ol> <li>Create a class called <code>CurrencyConverter</code>.</li> <li>Add the following class variables for exchange rates:<ul> <li><code>sgd_to_usd</code> (e.g. <code>0.74</code>)</li> <li><code>sgd_to_eur</code> (e.g. <code>0.68</code>)</li> <li><code>sgd_to_jpy</code> (e.g. <code>100.2</code>)</li> </ul> </li> <li>In the constructor (<code>__init__</code>), accept an amount in SGD and store it as an instance variable <code>sgd</code>.</li> <li> <p>Write instance methods that convert to each currency:</p> <ul> <li><code>to_usd()</code></li> <li><code>to_eur()</code></li> <li><code>to_jpy()</code></li> </ul> </li> </ol> <pre><code>c = CurrencyConverter(100)\nprint(c.to_usd())  # 74.0\nprint(c.to_eur())  # 68.0\nprint(c.to_jpy())  # 10020.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-2-class-methods-for-updating-rates","title":"Task 2: Class Methods for Updating Rates","text":"<p>Sometimes, currency rates change. Instead of updating the rate for each instance, we\u2019ll update the class variable using <code>@classmethod</code>.  </p> <p>Accomplish this by adding the following class methods:</p> <ul> <li><code>set_usd_rate(cls, new_rate)</code></li> <li><code>set_eur_rate(cls, new_rate)</code></li> <li><code>set_jpy_rate(cls, new_rate)</code></li> </ul> <p>Each method should update the corresponding class variable.</p> <pre><code>c1 = CurrencyConverter(100)\nprint(c1.to_eur())  # 68.0\nCurrencyConverter.set_eur_rate(0.75)\nprint(c1.to_eur())  # 75.0\n</code></pre>"},{"location":"exercises/04/ex04/#task-3-alternative-constructor","title":"Task 3: Alternative Constructor","text":"<p>Sometimes, we want to create a <code>CurrencyConverter</code> instance from EUR, and have it compute the SGD amount automatically based on the current exchange rate.</p> <p>Add a class method <code>from_eur(cls, eur_amount)</code> ,  <code>from_usd(cls, usd_amount)</code> and  <code>from_jpy(cls, jpy_amount)</code> that:</p> <ol> <li>Converts <code>CURR_amount</code> to SGD using the current <code>sgd_to_CURR</code> rate.</li> <li>Returns a new <code>CurrencyConverter</code> object with the computed SGD amount.</li> </ol> <pre><code>CurrencyConverter.set_eur_rate(0.75)\nc2 = CurrencyConverter.from_eur(75)\nprint(c2.sgd)       # 100.0\nprint(c2.to_eur())  # 75.0\n</code></pre>"},{"location":"exercises/05/ex05/","title":"05. Birds of a Feather","text":""},{"location":"exercises/05/ex05/#exercise-5-birds-of-a-feather","title":"Exercise 5: Birds of a Feather","text":"<p>In this exercise, you'll apply inheritance and method overriding to model a class hierarchy of birds. This will help you understand is-a relationships and when it makes sense to use inheritance to share and specialize behavior.</p>"},{"location":"exercises/05/ex05/#brief","title":"Brief","text":"<p>You\u2019re going to build a simple bird simulator using classes and inheritance to model a zoo's bird population. All birds share some common characteristics \u2014 like laying eggs and walking \u2014 but certain types of birds have additional abilities. For example, some birds can fly, others can swim, and some can\u2019t do either.</p> <p>Rather than duplicating code across all bird types, you\u2019ll use inheritance to model shared behavior in a base class Bird, and extend it in subclasses.</p> <p>The zoo has a bird population as follows:</p> <pre><code>1. Sparrow\n   \u2003Abilities: walk, lay egg, fly\n   \u2003Count: 2 (names: chirpy, flit)\n\n2. Penguin\n   \u2003Abilities: walk, lay egg, swim, dive\n   \u2003Count: 2 (names: tux, pebble)\n\n3. Ostrich\n   \u2003Abilities: walk, lay egg, swim\n   \u2003Count: 2 (names: dash, featherfoot)\n\n4. Parrot\n   \u2003Abilities: walk, lay egg, fly, mimic\n   \u2003Count: 2 (names: kiwi, echo)\n</code></pre> <p>Calling each action (e.g. <code>walk()</code>) should print something like:</p> <pre><code>flit (Parrot) walks\nflit (Parrot) lays an egg\nflit (Parrot) flies\nflit (Parrot) mimic a sound \n</code></pre>"},{"location":"exercises/05/ex05/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/05/ex05/#task-1-complete-class-diagram","title":"Task 1: Complete class diagram","text":"<p>Open the <code>classes.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code. Complete the class diagram for the all of the classes, specifying its attributes, methods and relationship.</p> <p>You should think of 2 suitable subclasses that help better model the relationship of the <code>Parrot</code>, <code>Ostrich</code> , <code>Penguin</code> , <code>Sparrow</code> classes. The base bird class has been completed for you. Override and add the required methods for your subclass.</p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before starting on task 3.</p>"},{"location":"exercises/05/ex05/#task-2-implement-the-code","title":"Task 2: Implement the code","text":"<p>Implement by following the class diagram above.</p>"},{"location":"exercises/05/ex05/#task-3-zoo-simulation","title":"Task 3: Zoo Simulation","text":"<p>Create a Zoo class that will manage the bird population.</p> <p>Requirements:</p> <ul> <li>Store each bird as an instance of its appropriate class</li> <li>New birds can be added birds to the zoo</li> <li>The Zoo should have a method display_all_actions that calls all the actions available for each bird in the zoo.</li> </ul> <p>Update your <code>classes.drawio</code> diagram.</p> <pre><code>Example Output:\nchirpy (Sparrow) walks\nchirpy (Sparrow) lays an egg\nchirpy (Sparrow) flies\nflit (Parrot) walks\nflit (Parrot) lays an egg\nflit (Parrot) flies\nflit (Parrot) mimic a sound \n...\n</code></pre>"},{"location":"exercises/05/ex05/#task-4-duckly-duck-multiple-inheritance","title":"Task 4: Duckly Duck \u2014 Multiple Inheritance","text":"<p>One of the zoo's new arrivals is a very special bird: Duckly. Duckly can not only walk, lay eggs, swim, fly and also quack!</p> <p>Create a new class <code>Duck</code> and use multiple inheritance in python to model Duckly\u2019s behavior. Update the class diagram and research on how multiple inheritance works in python. Add the Duckly to the Zoo.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is multiple inheritance in Python, and how is it different from single inheritance?</li> <li>What is the Method Resolution Order (MRO), and how does Python determine which method to call when multiple classes define the same method?</li> <li>Why might using multiple inheritance lead to ambiguity or conflicts? Can you give an example where this might happen?</li> <li>How does Python's super() function behave in a class that uses multiple inheritance? How can it help reduce code duplication?</li> </ol>"},{"location":"exercises/06/ex06/","title":"06. Messenger","text":""},{"location":"exercises/06/ex06/#exercise-6-messenger","title":"Exercise 6: Messenger","text":"<p>In this exercise, you'll be using default arguments in python to simulate overloading of methods with a suitable example to refactor.</p>"},{"location":"exercises/06/ex06/#brief","title":"Brief","text":"<p>You're tasked with writing a <code>Messenger</code> class that sends messages to recipients in different formats and via different methods. The message can vary depending on the amount of information provided by the user, such as the type of message (SMS, Email, App), an optional subject, attachments, or priority levels.</p> <p>In this task, your goal is to refactor the provided <code>Messenger</code> class so that it only contains one <code>send</code> method, which can handle all possible combinations of information. You'll use default parameters and Python's flexibility with arguments to simplify the process and avoid code duplication.</p>"},{"location":"exercises/06/ex06/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the provided GitHub Classroom link.</p>"},{"location":"exercises/06/ex06/#task-1-refactor-the-messenger-class","title":"Task 1: Refactor the Messenger Class","text":"<p>The provided <code>Messenger</code> class contains multiple methods for each combination of information. Refactor it so that there is only one method <code>send(...)</code> that can handle all cases based on the provided arguments.</p>"},{"location":"exercises/06/ex06/#task-2-test-and-submit","title":"Task 2: Test and Submit","text":"<ol> <li>After implementing the <code>send</code> method, write a few test in <code>main.py</code> cases to ensure your code works as expected.</li> <li>Test edge cases like:<ul> <li>No optional arguments.</li> <li>Only subject or attachment passed.</li> <li>Only priority passed.</li> </ul> </li> </ol>"},{"location":"exercises/07/ex07/","title":"07. Birds of a Feather 2","text":""},{"location":"exercises/07/ex07/#exercise-7-birds-of-a-feather-2","title":"Exercise 7: Birds of a Feather 2","text":"<p>In this exercise, you'll apply the use of abstract class and method where appropriate.</p>"},{"location":"exercises/07/ex07/#brief","title":"Brief","text":"<p>In Exercise 5, we implemented some birds such as <code>Parrot</code> and <code>Penguin</code>. However, some of these classes should not directly be initialized. Using what you learnt about abstract classes in Unit 07, determine which class should be abstract and convert them to abstract.</p> <p>You will be provided with the suggested solution to Exercise 5 as a starting point.</p>"},{"location":"exercises/07/ex07/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the GitHub Classroom link provided.</p>"},{"location":"exercises/07/ex07/#task-1-abstract-demo-method-abstract-class","title":"Task 1: Abstract <code>demo()</code> method &amp; Abstract Class","text":"<p>Implement the an method <code>demo</code> that must be available in all type bird. It should demonstrate all the abilities of the bird.</p> <p>For example, the demo method for <code>Parrot</code> should call all of the following methods:</p> <ul> <li>lay_egg()</li> <li>walk()</li> <li>fly()</li> <li>mimic()</li> </ul> <p>Open the <code>classes.drawio</code> file using draw.io or the \u2018Draw.io Integration\u2019 extension in VS Code. Complete the class diagram for the all of the classes, specifying its attributes, methods and relationship. Identify which classes should be abstract and clearly mark abstract classes and methods in the diagram</p> <p></p> <p>Checkpoint: Correct diagram</p> <p>Please confirm your class diagram with your teacher before starting on task 2.</p>"},{"location":"exercises/07/ex07/#task-2-refactor-the-code","title":"Task 2: Refactor the Code","text":"<p>Refactor the provided code to use abstract classes:</p> <ul> <li>Use Python\u2019s <code>abc</code> module to define abstract base classes and abstract methods.</li> <li>Ensure that all subclasses correctly implement the required abstract methods.</li> <li>The <code>Zoo</code> should now utilize the <code>demo</code> method for all birds.</li> </ul>"},{"location":"notes/01/basics/","title":"01. Basics","text":""},{"location":"notes/01/basics/#unit-01-basics","title":"Unit 01: Basics","text":""},{"location":"notes/01/basics/#the-3-rectangles-problem","title":"The 3 Rectangles Problem","text":"<p>Let\u2019s dive right in with an example. Suppose we have three rectangles as shown in the figure below and we would like to find the area and perimeter of each rectangle.</p> <p></p>"},{"location":"notes/01/basics/#the-naive-approach","title":"The Naive Approach","text":"<p>A straightforward approach to this problem is to represent each rectangle as a tuple containing its base and height, and store these tuples in a list. To compute the area and perimeter of each rectangle, we extract the base and height from each tuple and apply the following formulas:</p> <ul> <li>Area = base \u00d7 height</li> <li>Perimeter = 2 \u00d7 (base + height)</li> </ul> <pre><code>rectangles = [(1, 2), (3, 4), (5, 6)]\n\nrect: tuple\nfor i, rect in enumerate(rectangles):\n    base, height = rect\n    area = base * height\n    perimeter = 2 * (base + height)\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre>"},{"location":"notes/01/basics/#the-oop-approach","title":"The OOP Approach","text":"<p>Now, let's see how using objects can simplify this problem!</p> Step 1: CreateStep 2: Ask <p>Instead of using tuples, we create instances of a <code>Rectangle</code> class.</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n</code></pre> <p>Rather than manually calculating the area and perimeter, we simply ask each object for its area and perimeter!</p> <pre><code>rectangles = [Rectangle(1, 2), Rectangle(3, 4), Rectangle(5, 6)]\n\nrect: Rectangle\nfor i, rect in enumerate(rectangles):\n    area = rect.area()\n    perimeter = rect.perimeter()\n\n    print(f'Rectangle {i}: Area = {area}, Perimeter = {perimeter}')\n</code></pre> <p>Key Takeaway</p> <p>Notice the difference? In the OOP approach, we don\u2019t need to know the formulas for area and perimeter - the logic for those are encapsulated within the object and abstracted away from us. </p> <p>Abstraction and encapsulation is the practice of hiding complex implementation details and exposing only what\u2019s essential to the user. Just as high-level languages abstract away machine code, OOP lets you focus on what objects do, not how they do it. This makes code easier to read, maintain, and reuse, while reducing complexity as programs grow.</p> <p>In fact, you\u2019ve already been using objects all along. In Python, almost everything is an object. Perhaps the object you have used the most and are familiar with are strings; python strings are objects, and you likely have used many of the string object methods like isalpha(), isdigit(), etc. </p> <p>Have you ever wondered how those methods are actually implemented under the hood? Did you actually needed to know how it works under the hood?</p>"},{"location":"notes/01/basics/#creating-the-rectangle-class","title":"Creating the <code>Rectangle</code> Class","text":"<p>Now that we have seen how to use a object, let's actually create one!</p> Step 1: DeclarationStep 2: Attributes and ConstructorStep 3: Methods <p>We start by declaring the class we want to create.</p> <pre><code>class Rectangle:\n    ...\n</code></pre> <p>Next, we define a special method called <code>__init__</code>, known as the constructor. The constructor is automatically called when a new instance of the class is created. Here, we set up the initial state of the object by assigning values to its attributes.</p> <p>Attributes are variables that belong to an object and describe its properties. For a rectangle, we need its base and height, so we give it two attributes: <code>base</code> and <code>height</code>.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):   # self refers to the instance being created\n        self.base = base                # save base of the rectangle in the instance\n        self.height = height\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5) # Creating a rectangle instance: this internally calls Rectangle.__init__(10, 5)\n</code></pre> <p>Class vs Instance</p> <p>Declaring a class defines the blueprint for creating objects. An instance is an actual object (item) created from that blueprint.</p> <p>Finally, we implement the methods that will provide us with desired behaviors for our object.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return 2 * (self.base + self.height)\n\nif __name__ == '__main__':\n    rect1 = Rectangle(10, 5)\n    rect1.area()                # returns 50\n    rect1.perimeter()           # returns 30\n</code></pre>"},{"location":"notes/01/basics/#class-diagram","title":"Class Diagram","text":"<p>To help visualize classes, we often use a class diagram. A class diagram provides a concise overview of all the attributes and methods a class contains.</p> <p></p> <p>In the diagram above is the class diagram for <code>Rectangle</code>.  A class diagram typically consists of 3 rows in following template:</p> ClassName attributes: datatype method(signature): return datatype <p>Discussion</p> <p>Discussion questions (please discuss these with your teacher!):</p> <ol> <li> <p>What is the difference between a class and an instance of a class?</p> </li> <li> <p>What does it mean to say that a class abstracts something, and why is abstraction useful in programming?</p> </li> <li> <p>What does the <code>self</code> keyword refer to?</p> </li> </ol> <p>Jump to exercise 01</p>"},{"location":"notes/02/information-hiding/","title":"02. Information Hiding","text":""},{"location":"notes/02/information-hiding/#unit-02-information-hiding","title":"Unit 02: Information Hiding","text":""},{"location":"notes/02/information-hiding/#abstraction-layer","title":"Abstraction Layer","text":"<p>Building on Unit 1, another fundamental aspect of good object-oriented design is the principle of information hiding and maintaining the abstraction layer.</p> <p>In Python, there are fewer restrictions are enforced compared to other OOP focused language like Java or C++. This means it's easier to accidentally (or even intentionally) bypass the abstraction layer when working with OOP code - making it your responsibility as a programmer to respect and protect this boundary.</p> <p>Violating the abstraction layer often leads to a phenomenon known as \"spaghetti code\" where a codebase becomes so tangled and interdependent that even small changes can break your entire program.</p> <p></p>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-car-correctness","title":"Breaking the Abstraction Layer: Car (Correctness)","text":"<p>To understand what it means to break an abstraction layer, let's us consider the following <code>Car</code> class:</p> <pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self.position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self.position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self.position += distance\n</code></pre> <p>This class model a simple car driving along a 1D road. You can move the car by calling the <code>drive()</code> method, which updates its position by a given distance.</p> \u2705 Correct Usage (Abstraction Maintained)\u274c Broken Abstraction Layer <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car1.drive(10)\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This is the proper way to use the <code>Car</code> class. We instruct the car to drive, and let the internal logic handles the position update to the car instance.</p> <pre><code>def main():\n    car1 = Car(0)\n    print(car1)\n    car.position = car.position + 10\n    print(car1)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Now, instead of tell the car to drive like before, you\u2019re essentially now stepping out of the car and pushing the car manually.</p> <p>Imagine trying to drive a car, only for someone else to randomly push it from the outside! Likewise, directly changing attributes can often lead to unpredictable or buggy behavior.</p> <p>Tell, Don\u2019t Ask</p> <p>This example also breaks the \"Tell, Don\u2019t Ask\" principle, another core OOP principle which state that we should tell object to do something for us instead of asking for information and doing it ourself. </p> <ul> <li>\u2705 Correct: <code>car.drive(10)</code> \u2192 You instruct the car itself to move.</li> <li>\u274c Incorrect: <code>car.position = car.position + 10</code> \u2192 You ask for the car\u2019s position and change it manually.</li> </ul>"},{"location":"notes/02/information-hiding/#breaking-the-abstraction-layer-rectangle-maintainability","title":"Breaking the Abstraction Layer: Rectangle (Maintainability)","text":"<p>Apart from correctnesss, preserving the abstraction layer also makes your code easier to maintain and refactor if you like to make changes to it in the future.</p> <p>Let\u2019s revisit the <code>Rectangle</code> class from Unit 01:</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>Suppose that you initially calculated area and perimeter by accessing the class fields directly and hence broken the abstraction layer:</p> Broken abstraction layerOriginal Code <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.base * rect1.height                # 50\n    perimeter = 2 * (rect1.base + rect1.height)     # 30\n</code></pre> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 5)     \n    area = rect1.area()                             # 50\n    perimeter = rect1.perimeter()                   # 30\n</code></pre> <p>Later on, you might decide to represent a rectangle using its <code>base</code> and <code>area</code> instead of <code>height</code>. After all, only two of the three (base, height, area) are needed to compute the third - making this redesign valid.</p> New ClassOriginal Class <pre><code>class Rectangle:\n    def __init__(self, base, area):  \n        self.base = base               \n        self.area = area\n\n    def area(self):\n        return self.area\n\n    def perimeter(self):\n        return self.base * 2 + (self.area / self.base) * 2\n</code></pre> <pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self.base = base               \n        self.height = height\n\n    def area(self):\n        return self.base * self.height\n\n    def perimeter(self):\n        return self.base * 2 + self.height * 2\n</code></pre> <p>However, if you previously accessed fields directly and broken the abstraction layer, your main program will also break after this internal change to the <code>Rectangle</code> class:</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.base * rect1.height                # \u274c Broken\n    perimeter = 2 * (rect1.base + rect1.height)     # \u274c Broken\n</code></pre> <p>Now, the <code>height</code> attribute no longer exists, so these lines now cause errors.</p> <p>Whereas if the we used the class\u2019s methods (the abstraction layer), your code continues to work even after the internal changes to your class!</p> <pre><code>if __name__ == '__main__':\n    rect1 = Rectangle(10, 50)                       # Changed from 5-&gt;50\n    area = rect1.area()                             # \u2705 Still works\n    perimeter = rect1.perimeter()                   # \u2705 Still works\n</code></pre>"},{"location":"notes/02/information-hiding/#underscore-_-in-python","title":"Underscore _ in Python","text":"<p>To help preserve information hiding, Python provides a naming convention using the underscore (_) prefix to signal that a class attribute or method is meant for internal use only.</p> <p>While Python doesn't enforce access restrictions like private or protected keywords in other languages (e.g., Java or C++), the underscore acts as a convention that you - as programmers - should respect.</p> <p>Let\u2019s revise our earlier <code>Car</code> and <code>Rectangle</code> classes to follow this convention:</p> Revised Rectangle ClassRevised Car Class <p></p><pre><code>class Rectangle:\n    def __init__(self, base, height):  \n        self._base = base               \n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return self._base * 2 + self._height * 2\n</code></pre> We\u2019ve marked _base and _height as internal attributes, which means any calculations or logic outside this class should go through its public methods like area() or perimeter(). <p>Note that in the class diagram the <code>+</code> (public) sign is also flipped to <code>-</code> to indicate that it is a private/internal field.</p> <p></p> <p></p><pre><code>class Car:\n    def __init__(self, start_pos: int) -&gt; None:\n        self._position: int = start_pos\n\n    def __str__(self) -&gt; str:\n        return f\"Car is currently at position: {self._position}\"\n\n    def drive(self, distance: int) -&gt; None:\n        self._position += distance\n</code></pre> Likewise, _position is marked as internal. You\u2019re signaling to others (and to yourself) that the car\u2019s position should only be changed using drive(), and not accessed directly from outside.  <p>Using underscore naming convention</p> <p>Starting now, ALL of your attribute in your class should be internal by default. You will almost never need to use public attributes.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is the difference between accessing an attribute directly vs using a method? Why might direct access lead to problems in larger programs?</li> <li>Consider the principle \u201cTell, Don\u2019t Ask.\u201d Why might this lead to better object-oriented code?</li> <li>How does changing the internal implementation of a class (e.g., switching from height to area in <code>Rectangle</code>) illustrate the value of abstraction?</li> <li>Why should we use underscore in attributes and methods?</li> </ol> <p>Jump to exercise 02</p>"},{"location":"notes/03/composition/","title":"03. Composition","text":""},{"location":"notes/03/composition/#unit-03-composition","title":"Unit 03: Composition","text":""},{"location":"notes/03/composition/#car","title":"Car","text":"<p>Composition is yet another fundamental design principle whereby we compose objects with objects. This allows you to build complex systems flexibly, by combining simpler and smaller well-defined components.</p> <p>To illustrate composition, we'll build on from our car example from Unit 0.2</p>"},{"location":"notes/03/composition/#separate-classes-for-engine-and-brake","title":"Separate Classes for Engine and Brake","text":"<p>Every real car has an engine system and has a brake system. Hence, instead of bundling these directly into the <code>Car</code>, we can create distinct classes for each system.</p> EngineBrake <p>The <code>Engine</code> class models an engine that can be started or stopped, and calculates acceleration based on how much you press the pedal.</p> <pre><code>class Engine:\n\n    def __init__(self, max_acceleration: float) -&gt; None:\n        self._max_acceleration: float = max_acceleration\n        self._is_on: bool = False\n\n    def start(self) -&gt; None:\n        self._is_on = True\n\n    def stop(self) -&gt; None: \n        self._is_on = False\n\n    def is_running(self) -&gt; bool:\n        return self._is_on\n\n    def apply(self, paddle_ratio) -&gt; float:\n        if paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        if not self.is_running() and paddle_ratio &gt; 0:\n            raise Exception(\"The engine cannot accelerate when it is stopped.\")\n\n        return self._max_acceleration * paddle_ratio\n</code></pre> <p>The <code>Brake</code> class simulates how a brake gets worn down with use and calculates braking force accordingly.</p> <pre><code>class Brake:\n\n    def __init__(self, max_deceleration: float):\n        self._max_deceleration: float = max_deceleration\n        self._wear: float = 0                   \n\n    def apply(self, paddle_ratio: float) -&gt; float:\n        if paddle_ratio &gt; 1:\n            raise Exception(\"Paddle ratio must be between 0 and 1.\")\n\n        self._wear += 0.00001 * paddle_ratio    \n        # Braking effect reduces as wear increases, and is always negative (slows the car)\n        return self._max_deceleration * paddle_ratio * max(self._wear, 0.1) * -1\n</code></pre>"},{"location":"notes/03/composition/#composing-engine-and-brake-in-car","title":"Composing Engine and Brake in Car","text":"<p>By using the <code>Engine</code> and <code>Brake</code> objects to create the new <code>Car</code> class, we achieved composition. The logic for the <code>Brake</code> and <code>Engine</code> are encapsulated within their respectively classes. In other words, the systems are separate from each other.</p> <pre><code>class Car:\n    def __init__(self, start_pos: float, engine: Engine, brake: Brake) -&gt; None:\n        self._position: float = start_pos\n        self._speed = 0\n\n        self._engine: Engine = engine\n        self._brake: Brake = brake\n\n    def start(self) -&gt; None:\n        self._engine.start()\n\n    def stop(self) -&gt; None:\n        self._engine.stop()\n\n    def _accelerate(self, acceleration: float) -&gt; None:\n        # Internal method: should not be called directly from outside this class\n        dt = 1.0\n        v0 = self._speed\n        v1 = max(v0 + acceleration * dt, 0)\n        dx = 0.5 * (v0 + v1) * dt\n\n        self._speed = v1 \n        self._position += dx\n\n    def drive(self, paddle_ratio: float) -&gt; None:\n        acceleration = self._engine.apply(paddle_ratio)\n        self._accelerate(acceleration)\n\n    def brake(self, paddle_ratio: float) -&gt; None:\n        deceleration = self._brake.apply(paddle_ratio) # this is negative\n        self._accelerate(deceleration)\n</code></pre>"},{"location":"notes/03/composition/#class-diagram","title":"Class Diagram","text":"<p>The class diagram for the <code>Car</code> class looks like this:</p> <p></p> <p>The diamond-shaped arrows represents a 'has-a' relationship between objects</p>"},{"location":"notes/03/composition/#dangers-of-composition-references-aliasing","title":"Dangers of Composition: References / Aliasing","text":"<p>One danger when it comes to using composition is due to aliasing. As all objects in python are reference types, improperly managed aliasing may lead to unintended side effect.</p> <p>Study the code below. What do you expect to happen here and why? (hint: a line will throw an error)</p> ExampleAnswer: Part 1Answer: Part 2 <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    car1.start()\n    car2.start()\n    car1.drive(0.5)\n    car2.drive(0.5)\n\n    car1.stop()\n    car2.drive(0.3)\n\n    car2.stop()\n</code></pre> <pre><code>def main():\n    engine = Engine(100)\n    brake1 = Brake(200)\n    brake2 = Brake(300)\n\n    car1 = Car(0, engine, brake1)\n    car2 = Car(0, engine, brake2)\n\n    ...\n</code></pre> <p>The above example, we only created one engine object which both object are referencing. In other words, both cars sharing a reference to one engine.</p> <pre><code>def main():\n    ...\n    car1.stop()          # Stops the engine for BOTH car1 and car2\n    car2.drive(0.3)      # This will raise an Exception: \"The engine cannot accelerate when it is stopped\"\n    ...\n</code></pre> <p>Thus, when <code>car1.stop()</code> is called, it shuts down the shared engine. So, even though you're calling <code>car2.drive(0.3)</code> next, the engine is already stopped-triggering an exception.</p> <p>Unintended side effects</p> <p>When you pass objects in Python, you are passing references to the actual objects and not creating copies (unlike with primitive types like <code>int</code>, <code>float</code>). Always be mindful of this, especially when composing objects as sharing objects (aliasing) can have unintended side effects if not managed carefully!</p> <p>Immutable classes</p> <p>A possible way to safely manage this side effect is through the use of immutable classes. In other words, once the class is created all the attribute will never changes. </p> <p>A example of immutable class is python <code>str</code> class which will not change once it is created. Furthermore all methods (i.e slicing, replace, ...) of a str will always return a brand new str object rather then modifying the object. This immutability allows strings object to be safely passed around and shared without side effects.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What are the benefits of using composition instead of putting all functionality directly inside the Car class?</li> <li>What is object aliasing and why do you think it may make debugging harder in huge codebases systems?</li> <li>Why is _accelerate() marked with an underscore in the Car class? Should you call it from outside the class? Why or why not?</li> </ol> <p>Jump to exercise 03</p>"},{"location":"notes/04/class-field-method/","title":"04. Class Variables and Methods","text":""},{"location":"notes/04/class-field-method/#unit-04-class-fields-and-methods","title":"Unit 04: Class Fields and Methods","text":"<p>This unit will introduce you to the difference between instance and class variables/methods</p>"},{"location":"notes/04/class-field-method/#variables","title":"Variables","text":""},{"location":"notes/04/class-field-method/#instance-variables","title":"Instance Variables","text":"<p>As a recap, instance variables are used to store data unique to each object. They are defined with <code>self</code> inside the <code>__init__</code> constructor and belong to each specific instance of a class. Using the <code>Rectangle</code> class from Unit 01, we can see that the <code>Rectangle</code> class has 2 instance variables: base and height</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base         # instance variable\n        self._height = height     # instance variable\n\n    ...\n</code></pre> <p>Every <code>Rectangle</code> object instance has its own <code>base</code> and <code>height</code>, so changes to one object\u2019s instance variables won\u2019t affect others.</p>"},{"location":"notes/04/class-field-method/#class-variables","title":"Class Variables","text":"<p>In contrast, class variables are shared among all instances of a class. They are typically used for properties that should be consistent for every object, or to keep track of class-level information.</p> <p>For example, all rectangles have four sides, and you may want to count how many rectangles have been created:</p> <pre><code>class Rectangle:\n    SIDES = 4               # class variable (constant)\n    _count = 0              # class variable (for tracking)\n\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n        Rectangle._count += 1    # update class variable\n\n    ...\n</code></pre> <p>No matter how many <code>Rectangle</code> objects you create, both <code>SIDES</code> and <code>count</code> are shared and accessible from every instance and through the class itself.</p>"},{"location":"notes/04/class-field-method/#methods","title":"Methods","text":""},{"location":"notes/04/class-field-method/#instance-methods","title":"Instance Methods","text":"<p>Like instance variables, instance methods operate on individual objects and can access or modify instance variables. In Python, they always take <code>self</code> as their first parameter.</p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):                         # instance method\n        return self._base * self._height\n\n    ...\n</code></pre>"},{"location":"notes/04/class-field-method/#class-methods","title":"Class Methods","text":"<p>Similarly, class methods are used for operations that affect the class as a whole, not specific instances. They are defined with the <code>@classmethod</code> decorator and take <code>cls</code> as their first parameter.</p> <pre><code>class Rectangle:\n    _count = 0\n\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n        Rectangle._count += 1\n\n    @classmethod\n    def how_many(cls):              # class method\n        return cls._count           # cls here is Rectangle\n</code></pre> <p>Limited Access</p> <p>Class methods cannot access instance variables (since they don\u2019t have access to <code>self</code>), but can access class variables and other class methods.</p>"},{"location":"notes/04/class-field-method/#summary","title":"Summary","text":"<p>Summary Table</p> Field/Method Type How to Define Belongs To First Parameter Can Access Use Case Instance variable <code>self.base</code> Instance - Instance Data unique to each object Instance method <code>def area(self):</code> Instance <code>self</code> Instance Behavior based on instance attributes Class variable <code>count = 0</code> Class - Class Data shared by all instances Class method <code>@classmethod</code> Class <code>cls</code> Class Behavior related to the class itself <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is the difference between class and instance methods/variables?</li> <li>When do we use class methods/variables?</li> </ol> <p>Jump to exercise 04</p>"},{"location":"notes/05/subclasses/","title":"05. Inheritance and Subclasses","text":""},{"location":"notes/05/subclasses/#unit-05-inheritance-and-subclasses","title":"Unit 05: Inheritance and Subclasses","text":"<p>In Unit 03, we looked at how we can build complex classes using composition \u2014 that is, combining smaller classes together to model a has-a relationship. Now, we\u2019ll look at how to model an is-a relationship between classes using inheritance!</p>"},{"location":"notes/05/subclasses/#square-rectangle","title":"Square &amp; Rectangle","text":""},{"location":"notes/05/subclasses/#creating-a-square","title":"Creating a Square","text":"<p>Diving in, suppose we want to create a new class called <code>Square</code>. We might start off implementing it like this:</p> <pre><code>class Square:\n    def __init__(self, length):\n        self._base = length\n        self._height = length\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <p>Looks familiar, right? It\u2019s basically the exact same code as our Rectangle class from Unit 01. That\u2019s because a square is really just a special case of a rectangle where the base and height are equal.</p> <p>In other words, a square is a subset all rectangles</p> <p></p>"},{"location":"notes/05/subclasses/#inheriting-a-rectangle","title":"Inheriting a Rectangle","text":"<p>Thus, instead of rewriting all of <code>Rectangle</code> code in <code>Square</code>, we will make use of inheritance to reuse it:</p> New SquareRectangle <pre><code>class Square(Rectangle):                      # This tells Python that Square inherits from Rectangle\n    def __init__(self, length):\n        super().__init__(length, length)      # super() means \"call the parent class\", so this runs Rectangle's __init__\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Just like that, we're done! <code>Square</code> now has access to all the methods in <code>Rectangle</code>, automatically. Now we can say that <code>Square</code> is a subclass of <code>Rectangle</code> \u2014 or using the parent-child terminology, <code>Square</code> is the child and <code>Rectangle</code> is the parent. Or even, the <code>Square</code> extends <code>Rectangle</code>.</p> <p>The class diagram for this looks like:</p> <p></p> <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def __str__(self):\n        return f\"Rectangle with {self.get_base()} base and {self.get_height()} height\"\n\n    def get_base(self):\n        return self._base\n\n    def get_height(self):\n        return self._height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre>"},{"location":"notes/05/subclasses/#method-overriding","title":"Method Overriding","text":"<p>You might\u2019ve noticed that we defined a <code>__str__</code> method again inside our Square class.</p> <pre><code>class Square(Rectangle):                    \n    def __init__(self, length):\n        super().__init__(length, length)    \n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>What is happening here is called method overriding, we are replacing the <code>__str__</code> method from <code>Rectangle</code> with a new version specific to <code>Square</code>.</p> Without <code>__str__</code> methodWith <code>__str__</code> method <p>If we didn\u2019t define the <code>__str__</code> method in <code>Square</code>:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n</code></pre> <p>Then this code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Would give us:</p> <pre><code>Rectangle with 5 base and 5 height\n</code></pre> <p>This happens because <code>Square</code> didn't define its own <code>__str__</code>, so it just uses the one it inherited from Rectangle.</p> <p>But if we do define <code>__str__</code> in <code>Square</code>:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n</code></pre> <p>Then the same code:</p> <pre><code>sq = Square(5)\nprint(sq)\n</code></pre> <p>Will now give us:</p> <pre><code>Square with 5 length\n</code></pre> <p>Here, we\u2019ve overridden the <code>__str__</code> method from <code>Rectangle</code> with a new one tailored for <code>Square</code>.</p> <p>Method Resolution Order (MRO)</p> <p>When you call a method on an object, Python doesn\u2019t just randomly guess which method it should call. Python will follows a rule called the Method Resolution Order (MRO).</p> <p>Python first checks the child class (like <code>Square</code>). If the method exists there, it uses it. If not, it \"moves up\" to the parent (like <code>Rectangle</code>) and checks there and so on. So in our case, Python sees that <code>Square</code> has a <code>__str__</code> method in <code>Square</code>, and uses it. If it didn\u2019t, it would use the one from <code>Rectangle</code>.</p> <p>Note: Unlike other languages, python doesn\u2019t care how many arguments the method takes \u2014 it only checks the method name to decide if the method is overridden. If a child and parent both have a method with the same name, the child\u2019s version always takes priority.</p>"},{"location":"notes/05/subclasses/#adding-methods-to-subclasses","title":"Adding Methods to Subclasses","text":"<p>On top of just inheriting methods and attributes from our parent class, we can also define new methods in the child class to extend or specialize its behavior.</p> <p>Let\u2019s go back to our <code>Rectangle</code> and Square example. Suppose we want the Square class to have a method that tells us whether another square can fit inside a given area. That\u2019s something specific to squares \u2014 our <code>Rectangle</code> class doesn\u2019t need to know about it. We can add that method directly in Square:</p> <pre><code>class Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\n    def __str__(self):\n        return f\"Square with {self.get_base()} length\"\n\n    def can_fit(self, other: \"Square\"):\n        if not isinstance(other, Square):\n            raise TypeError(\"can_fit only works with other Square Objects\")\n\n        return self.area() &lt;= other.area()\n</code></pre> <p>This new <code>can_fit</code> method is only available on <code>Square</code>, not <code>Rectangle</code>. This show the  power of subclassing: we can start with shared behavior and add specific features when needed.</p> <p></p>"},{"location":"notes/05/subclasses/#negative-example-when-not-to-use-inheritance","title":"Negative example: When NOT to Use Inheritance","text":"<p>We\u2019ve learned that <code>Square</code> can inherit from <code>Rectangle</code>, because a square is a special kind of rectangle. That\u2019s an example of inheritance being used correctly \u2014 it makes sense. But not everything that shares some features should be related by inheritance.</p> <p>Let\u2019s look at a case where inheritance goes wrong with a flawed reasoning.</p> <p>Say we want our library to have a <code>name</code> attribute, then we also see that book class has the <code>name</code> attribute, and we recall that inheritance allow us to copy the attribute over to the subclass, we will make the library inherit from book!</p> <p>Imagine someone wrote the following:</p> <pre><code>class Book:\n    def __init__(self, name):\n        self._name = name\n\nclass Library(Book):  # \u26a0\ufe0f Uh-oh!\n    def __init__(self, name, books):\n        super().__init__(name)\n        self._books = books\n</code></pre> <p>This looks like <code>Library</code> is a kind of <code>Book</code>. But that doesn\u2019t really make sense! A library isn\u2019t a book, it just has books.</p> <p>To see why is may become a problem, let say we have a function that read a book:</p> <pre><code>def read(book: Book):\n\n    if not isinstance(book, Book):\n        raise TypeError(\"We can only read a book!\")\n\n    print(f'Reading: {book._name}')    # by right you should implement a getter method (i.e. get_name()) as this violate the abstraction layer / barrier \n\nread(lib)  # Wait \u2014 we\u2019re reading a library?! but our code is still working even tho we a check to ensure that we only can read books!\n</code></pre> <p>Even though we did a check for with <code>isinstance(book, Book)</code>, no error will occur because based on what we created earlier, we told Python that <code>Library</code> is special kind of <code>Book</code>. This is an example of using inheritance just to \u201creuse\u201d the name variable from <code>Book</code>. But it\u2019s the wrong relationship. A library has books. It is NOT a book.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>When do we use inheritance over composition?</li> <li>What is overriding and when might it be useful to override a method in a child class?</li> <li>How does python resolve a method with the same name in both the child and parent class? If a method is not available in child class, where does Python check next?  </li> </ol> <p>Jump to exercise 05</p>"},{"location":"notes/06/overloading/","title":"06. Overloading","text":""},{"location":"notes/06/overloading/#unit-06-overloading","title":"Unit 06: Overloading","text":"<p>While Python does not support traditional method overloading like Java or C++, we can achieve similar behavior through the use of default arguments. In this unit, we\u2019ll explore how Python simulates overloading and how you can implement flexible method interfaces.</p>"},{"location":"notes/06/overloading/#what-is-overloading","title":"What is Overloading?","text":"<p>In many programming languages, overloading allows you to define multiple versions of the same method, each with different parameters. For example in java:</p> <pre><code>int add(int a, int b) {\n    return a + b;\n}\nint add(int a, int b, int c) {\n    return a + b + c;\n}\n</code></pre> <p>But in Python, this does not work:</p> <pre><code>def add(a, b):\n    return a + b\n\ndef add(a, b, c):  # This will override the previous `add`\n    return a + b + c\n</code></pre> <p>Only the last function definition remains. Earlier ones are replaced.</p>"},{"location":"notes/06/overloading/#simulating-overloading","title":"Simulating Overloading","text":"<p>Since Python doesn't support overloading by default, we can simulate it using flexible parameters:</p> <pre><code>def add(a, b, c=0):  # we set c with a default value of 0. \n    return a + b + c\n</code></pre> <p>Now, like the java version, this works with 2 or 3 arguments:</p> <pre><code>add(1, 2)       # 3\nadd(1, 2, 3)    # 6\n</code></pre>"},{"location":"notes/06/overloading/#when-not-to-use-overloading","title":"When NOT to Use Overloading","text":"<p>While overloading is useful, but overusing flexible parameters can make code unclear; do not have one function that does everything</p> <pre><code>def do_stuff(*args, **kwargs):\n    # ???\n</code></pre> <p>Only use overloading for method that are similar in nature.</p> <p>Discussion</p> <p>Discussion questions (please discuss this with your teacher!)</p> <ol> <li>What is overloading and why is it useful?</li> <li>Why doesn\u2019t Python allow multiple functions with the same name like Java or C++? (hint there something to do with python being a dynamically typed language)</li> <li>How does using default parameters help us simulate overloading in Python? Find a function from Python's built-in libraries that uses default parameters like this.</li> </ol> <p>Jump to exercise 06</p>"},{"location":"notes/07/abstract/","title":"07. Abstract Classes","text":""},{"location":"notes/07/abstract/#unit-07-abstract-classes","title":"Unit 07: Abstract Classes","text":"<p>Recall that with inheritance, we are modeling an \"is-a\" relationship. Abstract classes are a natural extension of inheritance \u2014 with the key difference that an abstract class relies on its child classes to implement certain methods.</p> <p>In other words, abstract classes and methods are just concepts and ideas of the things you are trying to model.</p>"},{"location":"notes/07/abstract/#shapes","title":"Shapes","text":"<p>Consider a <code>Rectangle</code> class and a <code>Circle</code> class:</p> RectangleCircle <pre><code>class Rectangle:\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <pre><code>import math\n\nclass Circle:\n    def __init__(self, radius: float):\n        self._radius = radius\n\n    def diameter(self):\n        return self._radius * 2\n\n    def area(self):\n        return math.pi * self._radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self._radius\n</code></pre> <p>Both classes work independently, but they share a common identity where they are both shapes.</p>"},{"location":"notes/07/abstract/#introducing-an-abstract-base-class","title":"Introducing an Abstract Base Class","text":"<p>Now, perhaps we would like to enforce the fact that all shapes must implement both <code>area()</code> and <code>perimeter()</code>, we will make use of abstract class for this.</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n</code></pre> <p>Now, we can make both <code>Rectangle</code> and <code>Circle</code> subclasses of <code>Shape</code>,</p> RectangleCircle <pre><code>class Rectangle(Shape):\n    def __init__(self, base, height):\n        self._base = base\n        self._height = height\n\n    def area(self):\n        return self._base * self._height\n\n    def perimeter(self):\n        return 2 * (self._base + self._height)\n</code></pre> <pre><code>import math\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self._radius = radius\n\n    def area(self):\n        return math.pi * self._radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self._radius\n</code></pre> <p>Now we can treat both as Shapes:</p> <pre><code>shapes = [Rectangle(4, 5), Circle(3), \"I'm a shape too!\"]\n\nfor shape in shapes:\n\n    if isinstance(shape, Shape):\n        print(f'Area: {shape.area():.2f}')\n        print(f'Perimeter: {shape.perimeter():.2f}')\n    else:\n        print(f'You are not a shape, you imposter!')\n</code></pre>"},{"location":"notes/07/abstract/#what-happens-if-a-method-isnt-implemented","title":"What Happens If a Method Isn't Implemented?","text":""},{"location":"notes/07/abstract/#missing-implementation","title":"Missing implementation","text":"<p>Let\u2019s say we define a subclass that forgets to implement all the required methods:</p> <pre><code>class IncompleteShape(Shape):\n    def area(self):\n        return 0\n</code></pre> <p>This is missing the implementation for the <code>perimeter()</code> method, so trying to instantiate it:</p> <pre><code>shape = IncompleteShape()\n</code></pre> <p>Raises a <code>TypeError</code>:</p> <pre><code>TypeError: Can't instantiate abstract class IncompleteShape with abstract method perimeter\n</code></pre> <p>Python prevents you from creating objects from incomplete subclasses.</p>"},{"location":"notes/07/abstract/#instantiating-an-abstract-class","title":"Instantiating an abstract class","text":"<p>Likewise,</p> <pre><code>shape = Shape()     # a shape is a shape!\n</code></pre> <p>will not work as well. You cannot instantiate abstract class.</p> <p>Discussion</p> <p>Discussion questions (please discuss these with your teacher!):</p> <ol> <li>What is the purpose of an abstract base class, and how is it different from a regular parent class?</li> <li>What would happen if you tried to create an instance of the abstract <code>Shape</code> class directly?</li> <li>What happens if a subclass does not implement all of the abstract methods required by its abstract base class? Why is this behavior important? (hint: it a form of guarantee (confirm + chop))</li> </ol> <p>Jump to exercise 07</p>"},{"location":"proj/project/","title":"Pokemon Simulator","text":""},{"location":"proj/project/#pokemon-simulator","title":"Pok\u00e9mon Simulator","text":"<p>Welcome to the last and final part of the OOP topic! In this structured project, you will be guided through the process of designing classes and understanding the wide range of issues to consider when it comes to designing classes for the problem that you are trying to model or solve.</p> Teaser video <p></p>"},{"location":"proj/project/#background-information","title":"Background Information","text":"<p>In this project, you'll be building a Pok\u00e9mon Battle Simulator. But first, in order to figure out what classes to create, we need to understand the process of a Pok\u00e9mon battle.</p> <p>A typical Pok\u00e9mon battle consists of two teams of Pok\u00e9mon battling it out in a turn-by-turn fashion. Each round, one Pok\u00e9mon from each team is chosen to fight. They take turns performing attacks or utility functions. Each attack deals a certain amount of damage to the opponent based on the skill used, with modifiers based on type effectiveness, and other factors like stats or conditions</p> <p>The battle continues until all Pok\u00e9mon on one team have fainted. The team with the remaining Pok\u00e9mon is declared the winner.</p>"},{"location":"proj/project/#class-design","title":"Class Design","text":"<p>We will be designing a slightly slimmed-down version of a typical Pok\u00e9mon battle. You will only be focusing on core features of the game in a 1v1 combat setting. Utility functions like potions will not be implemented. (You are welcome to add it on your own tho!)</p>"},{"location":"proj/project/#candidates","title":"Candidates","text":"<p>The first step of any OOP problem is to identify the classes to create. Recall from the previous exercise, a tip to quickly narrow down the candidate is to identify the nouns and verbs of our problem.</p> <p>Finding the key nouns and verb from our problem description we will get the following table:</p> Nouns Verbs <code>Pokemon</code>, <code>team</code>, <code>battle</code>, <code>skill</code>, <code>attack</code>, <code>type</code>, <code>speed</code>, <code>damage</code>, <code>round</code>, <code>condition</code>, <code>stat</code>, <code>opponent</code>, <code>turn</code> <code>fight</code>, <code>attack</code>, <code>perform</code>, <code>deal</code>, <code>choose</code>, <code>faint</code>, <code>continue</code>, <code>declare</code>, <code>take</code>, <code>use</code>"},{"location":"proj/project/#considerations","title":"Considerations","text":"<p>After isolating the candidate, come the hard part of OOP design. At this stage you have consider many question and sub-questions such as:</p> <ol> <li>Which classes do I want to implement?<ol> <li>Which class are appropriate for the problem I'm trying to solve?</li> <li>What attributes should each class contain?</li> </ol> </li> <li>How would these classes interact with each other?<ol> <li>What are the relationship between the classes</li> <li>What behaviors or methods should each class support?</li> </ol> </li> <li>What overall design objectives of your program?<ol> <li>Will I need to add more features later (e.g., multi-Pok\u00e9mon teams, status effects, healing items)?</li> <li>Can I easily add new Pok\u00e9mon or moves without rewriting core logic?</li> </ol> </li> </ol> <p>Looking at all these questions, it not hard to see that a coming up good design is not an easy task. There is no one single correct way of doing things as different approach has it benefit and weaknesses. Coming up with a good OOP design typically come down to experience and practice.</p> <p>Luckily for you, someone (me) has spent hours doing the hard work of coming up with a good class design. As you will see later on, the many of the classes are designed with the goal of easy extensibility in mind.</p>"},{"location":"proj/project/#actual-design","title":"Actual Design","text":"<p>From the above, we will be working with the following core classes and associated actions:</p> Nouns (Classes) Verbs (Methods/Behaviors) <code>Pokemon</code>, <code>Skill</code>, <code>Attack</code>, <code>Modifier</code> <code>choose</code>, <code>attack</code>, <code>deal</code>, <code>faint</code>, <code>apply</code> <p>To understand why these classes are selected, let's revisit the key mechanics of a Pok\u00e9mon battle and how the relationships among these concepts can be modeled in OOP.</p> <p>One possible way to model the problem is as follows:</p> <ul> <li>A <code>Pokemon</code> has a few <code>Skill</code>.</li> <li>When a turn start, a <code>Pokemon</code> must choose a <code>Skill</code> to use against an opponent.</li> <li>When a <code>Skill</code> is chosen, an <code>Attack</code> is created to represent the action. The attack much have information such as the attacking <code>Pokemon</code> (caster), the defending <code>Pokemon</code> (opponent), the chosen <code>Skill</code>, and any <code>Modifier</code> to the attack that influence the damage dealt.</li> <li>The <code>Attack</code> is then applied (or executed), which causes the defending <code>Pokemon</code> to take damage.</li> <li>If a <code>Pokemon</code>'s HP falls to zero or below, it faints, and the battle is has ended.</li> </ul> <p>And to achieve more specialized behaviors, we will make use of inheritance and overriding for the <code>Pokemon</code>, <code>Skill</code>, and <code>Modifier</code> classes.</p> <p>Checkpoint: Understanding</p> <p>Please seek any clarification with your teacher if you are unclear or confused as it will be your turn to write some code soon!</p>"},{"location":"proj/project/#task-0-accept-the-assignment","title":"Task 0: Accept the Assignment","text":"<p>Accept the assignment using the GitHub Classroom link provided.</p>"},{"location":"proj/project/#task-1-attackmodifier","title":"Task 1: <code>AttackModifier</code>","text":"<p>We will start by creating an abstract class <code>AttackModifier</code> that implement one abstract method: <code>apply</code>. This class will allow as to transform our skill damage based on how the subclasses are defined. This will enable us to modify based on type effectiveness later down the line.</p> <p>The <code>apply()</code> method will take in 4 inputs:</p> <ul> <li>self</li> <li>damage: float</li> <li>pokemon: \"Pokemon\"</li> <li>skill: \"Skill\"</li> </ul> <p>Make sure to also add type hints to your code.</p> <p>Functor</p> <p>The above classes you have just created are known as a functor-like classes as they encapsulate a behavior (damage transformation in this case) in an object-oriented way.</p>"},{"location":"proj/project/#task-2-skill","title":"Task 2: <code>Skill</code>","text":"<p>Next, we will create the class to encapsulate and hold information about our skills. Create an abstract class <code>Skill</code> with the following specification:</p>"},{"location":"proj/project/#attributes-for-skill","title":"Attributes for <code>Skill</code>","text":"Attribute Description <code>_name</code> The name of the skill <code>_base_damage</code> The base damage of the skill <code>_max_charges</code> Maximum number of times the skill can be used <code>_modifiers</code> List of <code>AttackModifier</code>s applied when using this skill"},{"location":"proj/project/#methods-for-skill","title":"Methods for <code>Skill</code>","text":"Method Signature Description <code>get_name(self) -&gt; str</code> Returns the skill's name. <code>get_base_damage(self) -&gt; float</code> Returns the base damage value of the skill. <code>get_max_charges(self) -&gt; int</code> Returns the maximum number of times this skill can be used. <code>get_modifiers(self) -&gt; List[\"AttackModifier\"]</code> Returns a shallow copy of the list of <code>AttackModifier</code>s associated with this skill. (Why do we return a copy?) <code>get_type_name(self) -&gt; str</code> Abstract method. Subclasses must implement this to return the skill's type as a string."},{"location":"proj/project/#subclasses-of-skill","title":"Subclasses of <code>Skill</code>","text":"<p>Also implement the concrete subclasses of <code>GrassSkill</code>, <code>NormalSkill</code>, <code>FireSkill</code>, <code>WaterSkill</code>.</p> <p>Immutable class</p> <p>The above <code>Skill</code> class is designed as an immutable class since there only getter methods and the attributes of the class does not change once it created. This allow us to share the class around without worrying about side effects (see <code>abilities.py</code>)</p>"},{"location":"proj/project/#task-3-pokemon-abstract-class","title":"Task 3: <code>Pokemon</code> (Abstract Class)","text":"<p>Next we will implement the pokemon class. This class will hold all the information and behavior relating to a pokemon. Create an abstract class <code>Pokemon</code> with the following specifications:</p>"},{"location":"proj/project/#attributes-for-pokemon","title":"Attributes for <code>Pokemon</code>","text":"Attribute Description <code>_name</code> The pokemon's name. <code>_max_hp</code> The maximum hit points (HP) of the pokemon. <code>_hp</code> The current hit points of the pokemon. <code>_skills</code> List of <code>Skill</code> objects this pokemon has. <code>_skills_charges</code> List marking remaining uses (charges) for each skill. Parallel to <code>_skills</code> list. <code>_modifiers</code> List of <code>AttackModifier</code>s that affect this pokemon (optional)."},{"location":"proj/project/#methods-for-pokemon","title":"Methods for <code>Pokemon</code>","text":"Method Signature Description <code>get_name(self) -&gt; str</code> Returns the name of the pokemon. <code>get_skills(self) -&gt; List[\"Skill\"]</code> Returns a shallow copy of the pokemon's skill list. <code>add_skill(self, skill: \"Skill\") -&gt; None</code> Adds the given skill to <code>_skills</code> and initializes its max charges in <code>_skills_charges</code>. <code>take_damage(self, damage: float) -&gt; None</code> Reduces current HP by the given damage amount (never below zero). <code>is_alive(self) -&gt; bool</code> Returns <code>True</code> if current HP &gt; 0, else <code>False</code>. <code>hp_percentage(self) -&gt; float</code> Returns the current HP as a percentage of max HP. <code>get_attribute(self) -&gt; str</code> Abstract. Must return this pokemon\u2019s type as a string (e.g., <code>\"Grass\"</code>). <code>get_species_name(self) -&gt; str</code> Abstract. Must return this pokemon\u2019s species name as a string (e.g., <code>\"Bulbasaur\"</code>)."},{"location":"proj/project/#subclasses-of-pokemon","title":"Subclasses of <code>Pokemon</code>","text":"<p>Also implement the following subclasses: <code>GrassPokemon</code>, <code>WaterPokemon</code>, <code>FirePokemon</code>, <code>Charmander</code>, <code>Squirtle</code>, <code>Bulbasaur</code>.</p>"},{"location":"proj/project/#task-4-attack","title":"Task 4: <code>Attack</code>","text":"<p>The attack class will hold information of the current turn attack. This class is used together with the <code>Pokemon.create_attack()</code> method which we will implement in task 5. Create a class <code>Attack</code> with the following specifications:</p>"},{"location":"proj/project/#attributes-for-attack","title":"Attributes for <code>Attack</code>","text":"Attribute Description <code>_skill</code> The <code>Skill</code> object being used for this attack. <code>_target</code> The target <code>Pokemon</code> receiving the attack. <code>_attacker</code> The attacking <code>Pokemon</code>. <code>_damage</code> The current calculated damage value to be dealt (float). <code>_modifiers</code> List of <code>AttackModifier</code>s applied to this attack. <code>_changes</code> List of floats, each representing the change in damage after each modifier is applied. <code>_applied</code> Boolean flag: has this attack already been executed/applied?"},{"location":"proj/project/#methods-for-attack","title":"Methods for <code>Attack</code>","text":"Method Signature Description <code>add_modifier(self, modifier: \"AttackModifier\") -&gt; None</code> Applies a new modifier: calculates new damage, stores modifier, and records the change from this modifier. <code>apply(self) -&gt; None</code> Applies the attack damage to the target (calls the target's <code>take_damage</code>). Can only be called once per Attack. Raise an RuntimeError if called more than one <code>execute(self, is_player_attack: bool = True) -&gt; None</code> Handles the full attack sequence with print messages and animation, reporting hit or miss and KO status. <p>Implement the <code>Apply</code> and the <code>add_modifier</code> method for the <code>Attack</code> class. The  <code>execute()</code> method has already been done for you.</p>"},{"location":"proj/project/#task-5-creating-attacks","title":"Task 5: Creating Attacks","text":"<p>Now after implementing all of the classes above, we want to be able to create an attack. In order to create an attack, we need to implement the <code>create_attack</code> function in <code>Pokemon</code></p> <p>Requirements:</p> <p>This method must allow the current Pok\u00e9mon to use one of its skills as an attack against a specified opponent. It accept <code>opponent</code> Pok\u00e9mon and the <code>index</code> of the skill to use.</p> <p>The method must also:</p> <ul> <li>Raise a <code>ValueError</code> if the Pok\u00e9mon has no skills.</li> <li>Raise an <code>IndexError</code> if the specified skill index is out of range.</li> <li>Raise a <code>RuntimeError</code> if the selected skill has no remaining charges.</li> <li>Deduct one charge from the selected skill before creating the attack.</li> <li>Return the constructed <code>Attack</code> object.</li> </ul>"},{"location":"proj/project/#task-6-more-modifiers","title":"Task 6: More modifiers","text":"<p>Create the following new modifiers:</p> Modifier Class apply(...) Behavior AttackModifier Abstract method: must return a (possibly modified) float damage. PokemonTypeModifier If <code>pokemon</code> is an instance of a specified class, returns <code>damage * ratio</code>; otherwise, returns <code>damage</code>. AbilityModifier If <code>skill</code> is an instance of a specified class, returns <code>damage * ratio</code>; otherwise, returns <code>damage</code>. AccuracyModifier With specified probability, returns <code>damage</code>; otherwise, returns <code>0</code> (attack missed). CriticalHitModifier With specified probability, returns <code>damage * ratio</code> (critical hit); otherwise, returns <code>damage</code>. <p>Override the <code>__init__</code> method for various pokemon to include these default modifiers.</p>"},{"location":"proj/project/#task-7-additional-features","title":"Task 7: Additional features","text":"<p>Add a feature of your own to the simulator. Feel free to extend classes, create new class, etc.</p>"}]}